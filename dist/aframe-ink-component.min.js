(function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId]){return installedModules[moduleId].exports}var module=installedModules[moduleId]={i:moduleId,l:false,exports:{}};modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);module.l=true;return module.exports}__webpack_require__.m=modules;__webpack_require__.c=installedModules;__webpack_require__.i=function(value){return value};__webpack_require__.d=function(exports,name,getter){if(!__webpack_require__.o(exports,name)){Object.defineProperty(exports,name,{configurable:false,enumerable:true,get:getter})}};__webpack_require__.n=function(module){var getter=module&&module.__esModule?function getDefault(){return module["default"]}:function getModuleExports(){return module};__webpack_require__.d(getter,"a",getter);return getter};__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)};__webpack_require__.p="";return __webpack_require__(__webpack_require__.s=1)})([function(module,exports,__webpack_require__){(function(global,factory){true?factory(exports):typeof define==="function"&&define.amd?define(["exports"],factory):factory(global.inkjs={})})(this,function(exports){"use strict";class Path{constructor(){this._components=[];this._componentsString=null;this._isRelative=false;if(typeof arguments[0]=="string"){let componentsString=arguments[0];this.componentsString=componentsString}else if(arguments[0]instanceof Path.Component&&arguments[1]instanceof Path){let head=arguments[0];let tail=arguments[1];this._components.push(head);this._components=this._components.concat(tail._components)}else if(arguments[0]instanceof Array){let head=arguments[0];let relative=!!arguments[1];this._components=this._components.concat(head);this._isRelative=relative}}get isRelative(){return this._isRelative}get componentCount(){return this._components.length}get head(){if(this._components.length>0){return this._components[0]}else{return null}}get tail(){if(this._components.length>=2){let tailComps=this._components.slice(1,this._components.length);return new Path(tailComps)}else{return Path.self}}get length(){return this._components.length}get lastComponent(){let lastComponentIdx=this._components.length-1;if(lastComponentIdx>=0){return this._components[lastComponentIdx]}else{return null}}get containsNamedComponent(){for(let i=0,l=this._components.length;i<l;i++){if(!this._components[i].isIndex){return true}}return false}static get self(){let path=new Path;path._isRelative=true;return path}GetComponent(index){return this._components[index]}PathByAppendingPath(pathToAppend){let p=new Path;let upwardMoves=0;for(let i=0;i<pathToAppend._components.length;++i){if(pathToAppend._components[i].isParent){upwardMoves++}else{break}}for(let i=0;i<this._components.length-upwardMoves;++i){p._components.push(this._components[i])}for(let i=upwardMoves;i<pathToAppend._components.length;++i){p._components.push(pathToAppend._components[i])}return p}get componentsString(){if(this._componentsString==null){this._componentsString=this._components.join(".");if(this.isRelative)this._componentsString="."+this._componentsString}return this._componentsString}set componentsString(value){this._components.length=0;this._componentsString=value;if(this._componentsString==null||this._componentsString=="")return;if(this._componentsString[0]=="."){this._isRelative=true;this._componentsString=this._componentsString.substring(1)}let componentStrings=this._componentsString.split(".");for(let str of componentStrings){if(/^(\-|\+)?([0-9]+|Infinity)$/.test(str)){this._components.push(new Path.Component(parseInt(str)))}else{this._components.push(new Path.Component(str))}}}toString(){return this.componentsString}Equals(otherPath){if(otherPath==null)return false;if(otherPath._components.length!=this._components.length)return false;if(otherPath.isRelative!=this.isRelative)return false;for(let i=0,l=otherPath._components.length;i<l;i++){if(!otherPath._components[i].Equals(this._components[i]))return false}return true}PathByAppendingComponent(c){let p=new Path;p._components.push.apply(p._components,this._components);p._components.push(c);return p}}Path.parentId="^";(function(Path){class Component{constructor(indexOrName){this.index=-1;this.name=null;if(typeof indexOrName=="string"){this.name=indexOrName}else{this.index=indexOrName}}get isIndex(){return this.index>=0}get isParent(){return this.name==Path.parentId}static ToParent(){return new Component(Path.parentId)}toString(){if(this.isIndex){return this.index.toString()}else{return this.name}}Equals(otherComp){if(otherComp!=null&&otherComp.isIndex==this.isIndex){if(this.isIndex){return this.index==otherComp.index}else{return this.name==otherComp.name}}return false}}Path.Component=Component})(Path||(Path={}));var Debug;(function(Debug){function AssertType(variable,type,message){Assert(variable instanceof type,message)}Debug.AssertType=AssertType;function Assert(condition,message){if(!condition){if(typeof message!=="undefined"){console.warn(message)}if(console.trace){console.trace()}throw""}}Debug.Assert=Assert})(Debug||(Debug={}));function asOrNull(obj,type){if(obj instanceof type){return unsafeTypeAssertion(obj,type)}else{return null}}function asOrThrows(obj,type){if(obj instanceof type){return unsafeTypeAssertion(obj,type)}else{throw new Error(`${obj} is not of type ${type}`)}}function asNumberOrThrows(obj){if(typeof obj==="number"){return obj}else{throw new Error(`${obj} is not a number`)}}function asINamedContentOrNull(obj){if(obj.hasValidName&&obj.name){return obj}return null}function nullIfUndefined(obj){if(typeof obj==="undefined"){return null}return obj}function unsafeTypeAssertion(obj,type){return obj}class NullException extends Error{}function throwNullException(name){throw new NullException(`${name} is null or undefined`)}class InkObject{constructor(){this.parent=null;this._debugMetadata=null;this._path=null}get debugMetadata(){if(this._debugMetadata===null){if(this.parent){return this.parent.debugMetadata}}return this._debugMetadata}set debugMetadata(value){this._debugMetadata=value}get ownDebugMetadata(){return this._debugMetadata}DebugLineNumberOfPath(path){if(path===null)return null;let root=this.rootContentContainer;if(root){let targetContent=root.ContentAtPath(path).obj;if(targetContent){let dm=targetContent.debugMetadata;if(dm!==null){return dm.startLineNumber}}}return null}get path(){if(this._path==null){if(this.parent==null){this._path=new Path}else{let comps=[];let child=this;let container=asOrNull(child.parent,Container);while(container!==null){let namedChild=asINamedContentOrNull(child);if(namedChild!=null&&namedChild.hasValidName){comps.unshift(new Path.Component(namedChild.name))}else{comps.unshift(new Path.Component(container.content.indexOf(child)))}child=container;container=asOrNull(container.parent,Container)}this._path=new Path(comps)}}return this._path}ResolvePath(path){if(path===null)return throwNullException("path");if(path.isRelative){let nearestContainer=asOrNull(this,Container);if(nearestContainer===null){Debug.Assert(this.parent!==null,"Can't resolve relative path because we don't have a parent");nearestContainer=asOrNull(this.parent,Container);Debug.Assert(nearestContainer!==null,"Expected parent to be a container");Debug.Assert(path.GetComponent(0).isParent);path=path.tail}if(nearestContainer===null){return throwNullException("nearestContainer")}return nearestContainer.ContentAtPath(path)}else{let contentContainer=this.rootContentContainer;if(contentContainer===null){return throwNullException("contentContainer")}return contentContainer.ContentAtPath(path)}}ConvertPathToRelative(globalPath){let ownPath=this.path;let minPathLength=Math.min(globalPath.length,ownPath.length);let lastSharedPathCompIndex=-1;for(let i=0;i<minPathLength;++i){let ownComp=ownPath.GetComponent(i);let otherComp=globalPath.GetComponent(i);if(ownComp.Equals(otherComp)){lastSharedPathCompIndex=i}else{break}}if(lastSharedPathCompIndex==-1)return globalPath;let numUpwardsMoves=ownPath.componentCount-1-lastSharedPathCompIndex;let newPathComps=[];for(let up=0;up<numUpwardsMoves;++up)newPathComps.push(Path.Component.ToParent());for(let down=lastSharedPathCompIndex+1;down<globalPath.componentCount;++down)newPathComps.push(globalPath.GetComponent(down));let relativePath=new Path(newPathComps,true);return relativePath}CompactPathString(otherPath){let globalPathStr=null;let relativePathStr=null;if(otherPath.isRelative){relativePathStr=otherPath.componentsString;globalPathStr=this.path.PathByAppendingPath(otherPath).componentsString}else{let relativePath=this.ConvertPathToRelative(otherPath);relativePathStr=relativePath.componentsString;globalPathStr=otherPath.componentsString}if(relativePathStr.length<globalPathStr.length)return relativePathStr;else return globalPathStr}get rootContentContainer(){let ancestor=this;while(ancestor.parent){ancestor=ancestor.parent}return asOrNull(ancestor,Container)}Copy(){throw Error("Not Implemented: Doesn't support copying")}SetChild(obj,prop,value){if(obj[prop])obj[prop]=null;obj[prop]=value;if(obj[prop])obj[prop].parent=this}}class StringBuilder{constructor(str){str=typeof str!=="undefined"?str.toString():"";this.string=str}get Length(){return this.string.length}Append(str){if(str!==null){this.string+=str}}AppendLine(str){if(typeof str!=="undefined")this.Append(str);this.string+="\n"}AppendFormat(format,...args){this.string+=format.replace(/{(\d+)}/g,(match,num)=>{return typeof args[num]!="undefined"?args[num]:match})}toString(){return this.string}}class InkListItem{constructor(){this.originName=null;this.itemName=null;if(typeof arguments[1]!=="undefined"){let originName=arguments[0];let itemName=arguments[1];this.originName=originName;this.itemName=itemName}else if(arguments[0]){let fullName=arguments[0];let nameParts=fullName.toString().split(".");this.originName=nameParts[0];this.itemName=nameParts[1]}}static get Null(){return new InkListItem(null,null)}get isNull(){return this.originName==null&&this.itemName==null}get fullName(){return(this.originName!==null?this.originName:"?")+"."+this.itemName}toString(){return this.fullName}Equals(obj){if(obj instanceof InkListItem){let otherItem=obj;return otherItem.itemName==this.itemName&&otherItem.originName==this.originName}return false}copy(){return new InkListItem(this.originName,this.itemName)}serialized(){return JSON.stringify({originName:this.originName,itemName:this.itemName})}static fromSerializedKey(key){let obj=JSON.parse(key);if(!InkListItem.isLikeInkListItem(obj))return InkListItem.Null;let inkListItem=obj;return new InkListItem(inkListItem.originName,inkListItem.itemName)}static isLikeInkListItem(item){if(typeof item!=="object")return false;if(!item.hasOwnProperty("originName")||!item.hasOwnProperty("itemName"))return false;if(typeof item.originName!=="string"&&typeof item.originName!==null)return false;if(typeof item.itemName!=="string"&&typeof item.itemName!==null)return false;return true}}class InkList extends Map{constructor(){super((()=>{if(arguments[0]instanceof InkList){return arguments[0]}else{return undefined}})());this.origins=null;this._originNames=[];if(arguments[0]instanceof InkList){let otherList=arguments[0];if(otherList._originNames){this._originNames=otherList._originNames.slice()}}else if(typeof arguments[0]==="string"){let singleOriginListName=arguments[0];let originStory=arguments[1];this.SetInitialOriginName(singleOriginListName);let def=originStory.listDefinitions.TryListGetDefinition(singleOriginListName,null);if(def.exists){this.origins=[def.result]}else{throw new Error("InkList origin could not be found in story when constructing new list: "+singleOriginListName)}}else if(typeof arguments[0]==="object"&&arguments[0].hasOwnProperty("Key")&&arguments[0].hasOwnProperty("Value")){let singleElement=arguments[0];this.Add(singleElement.Key,singleElement.Value)}}AddItem(itemOrItemName){if(itemOrItemName instanceof InkListItem){let item=itemOrItemName;if(item.originName==null){this.AddItem(item.itemName);return}if(this.origins===null)return throwNullException("this.origins");for(let origin of this.origins){if(origin.name==item.originName){let intVal=origin.TryGetValueForItem(item,0);if(intVal.exists){this.Add(item,intVal.result);return}else{throw new Error("Could not add the item "+item+" to this list because it doesn't exist in the original list definition in ink.")}}}throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.")}else{let itemName=itemOrItemName;let foundListDef=null;if(this.origins===null)return throwNullException("this.origins");for(let origin of this.origins){if(itemName===null)return throwNullException("itemName");if(origin.ContainsItemWithName(itemName)){if(foundListDef!=null){throw new Error("Could not add the item "+itemName+" to this list because it could come from either "+origin.name+" or "+foundListDef.name)}else{foundListDef=origin}}}if(foundListDef==null)throw new Error("Could not add the item "+itemName+" to this list because it isn't known to any list definitions previously associated with this list.");let item=new InkListItem(foundListDef.name,itemName);let itemVal=foundListDef.ValueForItem(item);this.Add(item,itemVal)}}ContainsItemNamed(itemName){for(let[key,value]of this){let item=InkListItem.fromSerializedKey(key);if(item.itemName==itemName)return true}return false}ContainsKey(key){return this.has(key.serialized())}Add(key,value){let serializedKey=key.serialized();if(this.has(serializedKey)){throw new Error(`The Map already contains an entry for ${key}`)}this.set(serializedKey,value)}Remove(key){return this.delete(key.serialized())}get Count(){return this.size}get originOfMaxItem(){if(this.origins==null)return null;let maxOriginName=this.maxItem.Key.originName;let result=null;this.origins.every(origin=>{if(origin.name==maxOriginName){result=origin;return false}else return true});return result}get originNames(){if(this.Count>0){if(this._originNames==null&&this.Count>0)this._originNames=[];else{if(!this._originNames)this._originNames=[];this._originNames.length=0}for(let[key,value]of this){let item=InkListItem.fromSerializedKey(key);if(item.originName===null)return throwNullException("item.originName");this._originNames.push(item.originName)}}return this._originNames}SetInitialOriginName(initialOriginName){this._originNames=[initialOriginName]}SetInitialOriginNames(initialOriginNames){if(initialOriginNames==null)this._originNames=null;else this._originNames=initialOriginNames.slice()}get maxItem(){let max={Key:InkListItem.Null,Value:0};for(let[key,value]of this){let item=InkListItem.fromSerializedKey(key);if(max.Key.isNull||value>max.Value)max={Key:item,Value:value}}return max}get minItem(){let min={Key:InkListItem.Null,Value:0};for(let[key,value]of this){let item=InkListItem.fromSerializedKey(key);if(min.Key.isNull||value<min.Value){min={Key:item,Value:value}}}return min}get inverse(){let list=new InkList;if(this.origins!=null){for(let origin of this.origins){for(let[key,value]of origin.items){let item=InkListItem.fromSerializedKey(key);if(!this.ContainsKey(item))list.Add(item,value)}}}return list}get all(){let list=new InkList;if(this.origins!=null){for(let origin of this.origins){for(let[key,value]of origin.items){let item=InkListItem.fromSerializedKey(key);list.set(item.serialized(),value)}}}return list}Union(otherList){let union=new InkList(this);for(let[key,value]of otherList){union.set(key,value)}return union}Intersect(otherList){let intersection=new InkList;for(let[key,value]of this){if(otherList.has(key))intersection.set(key,value)}return intersection}Without(listToRemove){let result=new InkList(this);for(let[key,value]of listToRemove){result.delete(key)}return result}Contains(otherList){for(let[key,value]of otherList){if(!this.has(key))return false}return true}GreaterThan(otherList){if(this.Count==0)return false;if(otherList.Count==0)return true;return this.minItem.Value>otherList.maxItem.Value}GreaterThanOrEquals(otherList){if(this.Count==0)return false;if(otherList.Count==0)return true;return this.minItem.Value>=otherList.minItem.Value&&this.maxItem.Value>=otherList.maxItem.Value}LessThan(otherList){if(otherList.Count==0)return false;if(this.Count==0)return true;return this.maxItem.Value<otherList.minItem.Value}LessThanOrEquals(otherList){if(otherList.Count==0)return false;if(this.Count==0)return true;return this.maxItem.Value<=otherList.maxItem.Value&&this.minItem.Value<=otherList.minItem.Value}MaxAsList(){if(this.Count>0)return new InkList(this.maxItem);else return new InkList}MinAsList(){if(this.Count>0)return new InkList(this.minItem);else return new InkList}ListWithSubRange(minBound,maxBound){if(this.Count==0)return new InkList;let ordered=this.orderedItems;let minValue=0;let maxValue=Number.MAX_SAFE_INTEGER;if(Number.isInteger(minBound)){minValue=minBound}else{if(minBound instanceof InkList&&minBound.Count>0)minValue=minBound.minItem.Value}if(Number.isInteger(maxBound)){maxValue=maxBound}else{if(minBound instanceof InkList&&minBound.Count>0)maxValue=maxBound.maxItem.Value}let subList=new InkList;subList.SetInitialOriginNames(this.originNames);for(let item of ordered){if(item.Value>=minValue&&item.Value<=maxValue){subList.Add(item.Key,item.Value)}}return subList}Equals(otherInkList){if(otherInkList instanceof InkList===false)return false;if(otherInkList.Count!=this.Count)return false;for(let[key,value]of this){if(!otherInkList.has(key))return false}return true}get orderedItems(){let ordered=new Array;for(let[key,value]of this){let item=InkListItem.fromSerializedKey(key);ordered.push({Key:item,Value:value})}ordered.sort((x,y)=>{if(x.Key.originName===null){return throwNullException("x.Key.originName")}if(y.Key.originName===null){return throwNullException("y.Key.originName")}if(x.Value==y.Value){return x.Key.originName.localeCompare(y.Key.originName)}else{if(x.Value<y.Value)return-1;return x.Value>y.Value?1:0}});return ordered}toString(){let ordered=this.orderedItems;let sb=new StringBuilder;for(let i=0;i<ordered.length;i++){if(i>0)sb.Append(", ");let item=ordered[i].Key;if(item.itemName===null)return throwNullException("item.itemName");sb.Append(item.itemName)}return sb.toString()}valueOf(){return NaN}}class StoryException extends Error{constructor(message){super(message);this.useEndLineNumber=false;this.message=message;this.name="StoryException"}}function tryGetValueFromMap(map,key,value){if(map===null){return{result:value,exists:false}}let val=map.get(key);if(val){return{result:val,exists:true}}else{return{result:value,exists:false}}}function tryParseInt(value,defaultValue=0){let val=parseInt(value);if(!Number.isNaN(val)){return{result:val,exists:true}}else{return{result:defaultValue,exists:false}}}function tryParseFloat(value,defaultValue=0){let val=parseFloat(value);if(!Number.isNaN(val)){return{result:val,exists:true}}else{return{result:defaultValue,exists:false}}}class AbstractValue extends InkObject{static Create(val){if(typeof val==="boolean"){let b=!!val;val=b?1:0}if(Number.isInteger(Number(val))){return new IntValue(Number(val))}else if(!isNaN(val)){return new FloatValue(Number(val))}else if(typeof val==="string"){return new StringValue(String(val))}else if(val instanceof Path){return new DivertTargetValue(asOrThrows(val,Path))}else if(val instanceof InkList){return new ListValue(asOrThrows(val,InkList))}return null}Copy(){return asOrThrows(AbstractValue.Create(this),InkObject)}BadCastException(targetType){return new StoryException("Can't cast "+this.valueObject+" from "+this.valueType+" to "+targetType)}}class Value extends AbstractValue{constructor(val){super();this.value=val}get valueObject(){return this.value}toString(){if(this.value===null)return throwNullException("Value.value");return this.value.toString()}}class IntValue extends Value{constructor(val){super(val||0)}get isTruthy(){return this.value!=0}get valueType(){return ValueType.Int}Cast(newType){if(this.value===null)return throwNullException("Value.value");if(newType==this.valueType){return this}if(newType==ValueType.Float){return new FloatValue(this.value)}if(newType==ValueType.String){return new StringValue(""+this.value)}throw this.BadCastException(newType)}}class FloatValue extends Value{constructor(val){super(val||0)}get isTruthy(){return this.value!=0}get valueType(){return ValueType.Float}Cast(newType){if(this.value===null)return throwNullException("Value.value");if(newType==this.valueType){return this}if(newType==ValueType.Int){return new IntValue(this.value)}if(newType==ValueType.String){return new StringValue(""+this.value)}throw this.BadCastException(newType)}}class StringValue extends Value{constructor(val){super(val||"");this._isNewline=this.value=="\n";this._isInlineWhitespace=true;if(this.value===null)return throwNullException("Value.value");if(this.value.length>0){this.value.split("").every(c=>{if(c!=" "&&c!="\t"){this._isInlineWhitespace=false;return false}return true})}}get valueType(){return ValueType.String}get isTruthy(){if(this.value===null)return throwNullException("Value.value");return this.value.length>0}get isNewline(){return this._isNewline}get isInlineWhitespace(){return this._isInlineWhitespace}get isNonWhitespace(){return!this.isNewline&&!this.isInlineWhitespace}Cast(newType){if(newType==this.valueType){return this}if(newType==ValueType.Int){let parsedInt=tryParseInt(this.value);if(parsedInt.exists){return new IntValue(parsedInt.result)}else{throw this.BadCastException(newType)}}if(newType==ValueType.Float){let parsedFloat=tryParseFloat(this.value);if(parsedFloat.exists){return new FloatValue(parsedFloat.result)}else{throw this.BadCastException(newType)}}throw this.BadCastException(newType)}}class DivertTargetValue extends Value{constructor(targetPath){super(targetPath)}get valueType(){return ValueType.DivertTarget}get targetPath(){if(this.value===null)return throwNullException("Value.value");return this.value}set targetPath(value){this.value=value}get isTruthy(){throw new Error("Shouldn't be checking the truthiness of a divert target")}Cast(newType){if(newType==this.valueType)return this;throw this.BadCastException(newType)}toString(){return"DivertTargetValue("+this.targetPath+")"}}class VariablePointerValue extends Value{constructor(variableName,contextIndex=-1){super(variableName);this._contextIndex=contextIndex}get contextIndex(){return this._contextIndex}set contextIndex(value){this._contextIndex=value}get variableName(){if(this.value===null)return throwNullException("Value.value");return this.value}set variableName(value){this.value=value}get valueType(){return ValueType.VariablePointer}get isTruthy(){throw new Error("Shouldn't be checking the truthiness of a variable pointer")}Cast(newType){if(newType==this.valueType)return this;throw this.BadCastException(newType)}toString(){return"VariablePointerValue("+this.variableName+")"}Copy(){return new VariablePointerValue(this.variableName,this.contextIndex)}}class ListValue extends Value{get isTruthy(){if(this.value===null){return throwNullException("this.value")}return this.value.Count>0}get valueType(){return ValueType.List}Cast(newType){if(this.value===null)return throwNullException("Value.value");if(newType==ValueType.Int){let max=this.value.maxItem;if(max.Key.isNull)return new IntValue(0);else return new IntValue(max.Value)}else if(newType==ValueType.Float){let max=this.value.maxItem;if(max.Key.isNull)return new FloatValue(0);else return new FloatValue(max.Value)}else if(newType==ValueType.String){let max=this.value.maxItem;if(max.Key.isNull)return new StringValue("");else{return new StringValue(max.Key.toString())}}if(newType==this.valueType)return this;throw this.BadCastException(newType)}constructor(listOrSingleItem,singleValue){super(null);if(!listOrSingleItem&&!singleValue){this.value=new InkList}else if(listOrSingleItem instanceof InkList){this.value=new InkList(listOrSingleItem)}else if(listOrSingleItem instanceof InkListItem&&typeof singleValue==="number"){this.value=new InkList({Key:listOrSingleItem,Value:singleValue})}}static RetainListOriginsForAssignment(oldValue,newValue){let oldList=asOrNull(oldValue,ListValue);let newList=asOrNull(newValue,ListValue);if(newList&&newList.value===null)return throwNullException("newList.value");if(oldList&&oldList.value===null)return throwNullException("oldList.value");if(oldList&&newList&&newList.value.Count==0)newList.value.SetInitialOriginNames(oldList.value.originNames)}}var ValueType;(function(ValueType){ValueType[ValueType["Int"]=0]="Int";ValueType[ValueType["Float"]=1]="Float";ValueType[ValueType["List"]=2]="List";ValueType[ValueType["String"]=3]="String";ValueType[ValueType["DivertTarget"]=4]="DivertTarget";ValueType[ValueType["VariablePointer"]=5]="VariablePointer"})(ValueType||(ValueType={}));class SearchResult{constructor(){this.obj=null;this.approximate=false}get correctObj(){return this.approximate?null:this.obj}get container(){return this.obj instanceof Container?this.obj:null}copy(){let searchResult=new SearchResult;searchResult.obj=this.obj;searchResult.approximate=this.approximate;return searchResult}}class Container extends InkObject{constructor(){super(...arguments);this.name="";this._content=[];this.namedContent=new Map;this.visitsShouldBeCounted=false;this.turnIndexShouldBeCounted=false;this.countingAtStartOnly=false;this._pathToFirstLeafContent=null}get hasValidName(){return this.name!=null&&this.name.length>0}get content(){return this._content}set content(value){this.AddContent(value)}get namedOnlyContent(){let namedOnlyContentDict=new Map;for(let[key,value]of this.namedContent){let inkObject=asOrThrows(value,InkObject);namedOnlyContentDict.set(key,inkObject)}for(let c of this.content){let named=asINamedContentOrNull(c);if(named!=null&&named.hasValidName){namedOnlyContentDict.delete(named.name)}}if(namedOnlyContentDict.size==0)namedOnlyContentDict=null;return namedOnlyContentDict}set namedOnlyContent(value){let existingNamedOnly=this.namedOnlyContent;if(existingNamedOnly!=null){for(let[key,val]of existingNamedOnly){this.namedContent.delete(key)}}if(value==null)return;for(let[key,val]of value){let named=asINamedContentOrNull(val);if(named!=null)this.AddToNamedContentOnly(named)}}get countFlags(){let flags=0;if(this.visitsShouldBeCounted)flags|=Container.CountFlags.Visits;if(this.turnIndexShouldBeCounted)flags|=Container.CountFlags.Turns;if(this.countingAtStartOnly)flags|=Container.CountFlags.CountStartOnly;if(flags==Container.CountFlags.CountStartOnly){flags=0}return flags}set countFlags(value){let flag=value;if((flag&Container.CountFlags.Visits)>0)this.visitsShouldBeCounted=true;if((flag&Container.CountFlags.Turns)>0)this.turnIndexShouldBeCounted=true;if((flag&Container.CountFlags.CountStartOnly)>0)this.countingAtStartOnly=true}get pathToFirstLeafContent(){if(this._pathToFirstLeafContent==null)this._pathToFirstLeafContent=this.path.PathByAppendingPath(this.internalPathToFirstLeafContent);return this._pathToFirstLeafContent}get internalPathToFirstLeafContent(){let components=[];let container=this;while(container instanceof Container){if(container.content.length>0){components.push(new Path.Component(0));container=container.content[0]}}return new Path(components)}AddContent(contentObjOrList){if(contentObjOrList instanceof Array){let contentList=contentObjOrList;for(let c of contentList){this.AddContent(c)}}else{let contentObj=contentObjOrList;this._content.push(contentObj);if(contentObj.parent){throw new Error("content is already in "+contentObj.parent)}contentObj.parent=this;this.TryAddNamedContent(contentObj)}}TryAddNamedContent(contentObj){let namedContentObj=asINamedContentOrNull(contentObj);if(namedContentObj!=null&&namedContentObj.hasValidName){this.AddToNamedContentOnly(namedContentObj)}}AddToNamedContentOnly(namedContentObj){Debug.AssertType(namedContentObj,InkObject,"Can only add Runtime.Objects to a Runtime.Container");let runtimeObj=asOrThrows(namedContentObj,InkObject);runtimeObj.parent=this;this.namedContent.set(namedContentObj.name,namedContentObj)}ContentAtPath(path,partialPathStart=0,partialPathLength=-1){if(partialPathLength==-1)partialPathLength=path.length;let result=new SearchResult;result.approximate=false;let currentContainer=this;let currentObj=this;for(let i=partialPathStart;i<partialPathLength;++i){let comp=path.GetComponent(i);if(currentContainer==null){result.approximate=true;break}let foundObj=currentContainer.ContentWithPathComponent(comp);if(foundObj==null){result.approximate=true;break}currentObj=foundObj;currentContainer=asOrNull(foundObj,Container)}result.obj=currentObj;return result}InsertContent(contentObj,index){this.content[index]=contentObj;if(contentObj.parent){throw new Error("content is already in "+contentObj.parent)}contentObj.parent=this;this.TryAddNamedContent(contentObj)}AddContentsOfContainer(otherContainer){this.content=this.content.concat(otherContainer.content);for(let obj of otherContainer.content){obj.parent=this;this.TryAddNamedContent(obj)}}ContentWithPathComponent(component){if(component.isIndex){if(component.index>=0&&component.index<this.content.length){return this.content[component.index]}else{return null}}else if(component.isParent){return this.parent}else{if(component.name===null){return throwNullException("component.name")}let foundContent=tryGetValueFromMap(this.namedContent,component.name,null);if(foundContent.exists){return asOrThrows(foundContent.result,InkObject)}else{return null}}}BuildStringOfHierarchy(){let sb;if(arguments.length==0){sb=new StringBuilder;this.BuildStringOfHierarchy(sb,0,null);return sb.toString()}sb=arguments[0];let indentation=arguments[1];let pointedObj=arguments[2];function appendIndentation(){const spacesPerIndent=4;for(let i=0;i<spacesPerIndent*indentation;++i){sb.Append(" ")}}appendIndentation();sb.Append("[");if(this.hasValidName){sb.AppendFormat(" ({0})",this.name)}if(this==pointedObj){sb.Append("  <---")}sb.AppendLine();indentation++;for(let i=0;i<this.content.length;++i){let obj=this.content[i];if(obj instanceof Container){let container=obj;container.BuildStringOfHierarchy(sb,indentation,pointedObj)}else{appendIndentation();if(obj instanceof StringValue){sb.Append('"');sb.Append(obj.toString().replace("\n","\\n"));sb.Append('"')}else{sb.Append(obj.toString())}}if(i!=this.content.length-1){sb.Append(",")}if(!(obj instanceof Container)&&obj==pointedObj){sb.Append("  <---")}sb.AppendLine()}let onlyNamed=new Map;for(let[key,value]of this.namedContent){if(this.content.indexOf(asOrThrows(value,InkObject))>=0){continue}else{onlyNamed.set(key,value)}}if(onlyNamed.size>0){appendIndentation();sb.AppendLine("-- named: --");for(let[key,value]of onlyNamed){Debug.AssertType(value,Container,"Can only print out named Containers");let container=value;container.BuildStringOfHierarchy(sb,indentation,pointedObj);sb.AppendLine()}}indentation--;appendIndentation();sb.Append("]")}}(function(Container){let CountFlags;(function(CountFlags){CountFlags[CountFlags["Visits"]=1]="Visits";CountFlags[CountFlags["Turns"]=2]="Turns";CountFlags[CountFlags["CountStartOnly"]=4]="CountStartOnly"})(CountFlags=Container.CountFlags||(Container.CountFlags={}))})(Container||(Container={}));class Glue extends InkObject{toString(){return"Glue"}}class ControlCommand extends InkObject{get commandType(){return this._commandType}constructor(commandType=ControlCommand.CommandType.NotSet){super();this._commandType=commandType}Copy(){return new ControlCommand(this.commandType)}static EvalStart(){return new ControlCommand(ControlCommand.CommandType.EvalStart)}static EvalOutput(){return new ControlCommand(ControlCommand.CommandType.EvalOutput)}static EvalEnd(){return new ControlCommand(ControlCommand.CommandType.EvalEnd)}static Duplicate(){return new ControlCommand(ControlCommand.CommandType.Duplicate)}static PopEvaluatedValue(){return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue)}static PopFunction(){return new ControlCommand(ControlCommand.CommandType.PopFunction)}static PopTunnel(){return new ControlCommand(ControlCommand.CommandType.PopTunnel)}static BeginString(){return new ControlCommand(ControlCommand.CommandType.BeginString)}static EndString(){return new ControlCommand(ControlCommand.CommandType.EndString)}static NoOp(){return new ControlCommand(ControlCommand.CommandType.NoOp)}static ChoiceCount(){return new ControlCommand(ControlCommand.CommandType.ChoiceCount)}static Turns(){return new ControlCommand(ControlCommand.CommandType.Turns)}static TurnsSince(){return new ControlCommand(ControlCommand.CommandType.TurnsSince)}static ReadCount(){return new ControlCommand(ControlCommand.CommandType.ReadCount)}static Random(){return new ControlCommand(ControlCommand.CommandType.Random)}static SeedRandom(){return new ControlCommand(ControlCommand.CommandType.SeedRandom)}static VisitIndex(){return new ControlCommand(ControlCommand.CommandType.VisitIndex)}static SequenceShuffleIndex(){return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex)}static StartThread(){return new ControlCommand(ControlCommand.CommandType.StartThread)}static Done(){return new ControlCommand(ControlCommand.CommandType.Done)}static End(){return new ControlCommand(ControlCommand.CommandType.End)}static ListFromInt(){return new ControlCommand(ControlCommand.CommandType.ListFromInt)}static ListRange(){return new ControlCommand(ControlCommand.CommandType.ListRange)}static ListRandom(){return new ControlCommand(ControlCommand.CommandType.ListRandom)}toString(){return this.commandType.toString()}}(function(ControlCommand){let CommandType;(function(CommandType){CommandType[CommandType["NotSet"]=-1]="NotSet";CommandType[CommandType["EvalStart"]=0]="EvalStart";CommandType[CommandType["EvalOutput"]=1]="EvalOutput";CommandType[CommandType["EvalEnd"]=2]="EvalEnd";CommandType[CommandType["Duplicate"]=3]="Duplicate";CommandType[CommandType["PopEvaluatedValue"]=4]="PopEvaluatedValue";CommandType[CommandType["PopFunction"]=5]="PopFunction";CommandType[CommandType["PopTunnel"]=6]="PopTunnel";CommandType[CommandType["BeginString"]=7]="BeginString";CommandType[CommandType["EndString"]=8]="EndString";CommandType[CommandType["NoOp"]=9]="NoOp";CommandType[CommandType["ChoiceCount"]=10]="ChoiceCount";CommandType[CommandType["Turns"]=11]="Turns";CommandType[CommandType["TurnsSince"]=12]="TurnsSince";CommandType[CommandType["Random"]=13]="Random";CommandType[CommandType["SeedRandom"]=14]="SeedRandom";CommandType[CommandType["VisitIndex"]=15]="VisitIndex";CommandType[CommandType["SequenceShuffleIndex"]=16]="SequenceShuffleIndex";CommandType[CommandType["StartThread"]=17]="StartThread";CommandType[CommandType["Done"]=18]="Done";CommandType[CommandType["End"]=19]="End";CommandType[CommandType["ListFromInt"]=20]="ListFromInt";CommandType[CommandType["ListRange"]=21]="ListRange";CommandType[CommandType["ListRandom"]=22]="ListRandom";CommandType[CommandType["ReadCount"]=23]="ReadCount";CommandType[CommandType["TOTAL_VALUES"]=24]="TOTAL_VALUES"})(CommandType=ControlCommand.CommandType||(ControlCommand.CommandType={}))})(ControlCommand||(ControlCommand={}));var PushPopType;(function(PushPopType){PushPopType[PushPopType["Tunnel"]=0]="Tunnel";PushPopType[PushPopType["Function"]=1]="Function";PushPopType[PushPopType["FunctionEvaluationFromGame"]=2]="FunctionEvaluationFromGame"})(PushPopType||(PushPopType={}));class Pointer{constructor(){this.container=null;this.index=-1;if(arguments.length===2){this.container=arguments[0];this.index=arguments[1]}}Resolve(){if(this.index<0)return this.container;if(this.container==null)return null;if(this.container.content.length==0)return this.container;if(this.index>=this.container.content.length)return null;return this.container.content[this.index]}get isNull(){return this.container==null}get path(){if(this.isNull)return null;if(this.index>=0)return this.container.path.PathByAppendingComponent(new Path.Component(this.index));else return this.container.path}toString(){if(!this.container)return"Ink Pointer (null)";return"Ink Pointer -> "+this.container.path.toString()+" -- index "+this.index}copy(){return new Pointer(this.container,this.index)}static StartOf(container){return new Pointer(container,0)}static get Null(){return new Pointer(null,-1)}}class Divert extends InkObject{constructor(stackPushType){super();this._targetPath=null;this._targetPointer=Pointer.Null;this.variableDivertName=null;this.pushesToStack=false;this.stackPushType=0;this.isExternal=false;this.externalArgs=0;this.isConditional=false;this.pushesToStack=false;if(typeof stackPushType!=="undefined"){this.pushesToStack=true;this.stackPushType=stackPushType}}get targetPath(){if(this._targetPath!=null&&this._targetPath.isRelative){let targetObj=this.targetPointer.Resolve();if(targetObj){this._targetPath=targetObj.path}}return this._targetPath}set targetPath(value){this._targetPath=value;this._targetPointer=Pointer.Null}get targetPointer(){if(this._targetPointer.isNull){let targetObj=this.ResolvePath(this._targetPath).obj;if(this._targetPath===null)return throwNullException("this._targetPath");if(this._targetPath.lastComponent===null)return throwNullException("this._targetPath.lastComponent");if(this._targetPath.lastComponent.isIndex){if(targetObj===null)return throwNullException("targetObj");this._targetPointer.container=targetObj.parent instanceof Container?targetObj.parent:null;this._targetPointer.index=this._targetPath.lastComponent.index}else{this._targetPointer=Pointer.StartOf(targetObj instanceof Container?targetObj:null)}}return this._targetPointer.copy()}get targetPathString(){if(this.targetPath==null)return null;return this.CompactPathString(this.targetPath)}set targetPathString(value){if(value==null){this.targetPath=null}else{this.targetPath=new Path(value)}}get hasVariableTarget(){return this.variableDivertName!=null}Equals(obj){let otherDivert=obj;if(otherDivert instanceof Divert){if(this.hasVariableTarget==otherDivert.hasVariableTarget){if(this.hasVariableTarget){return this.variableDivertName==otherDivert.variableDivertName}else{if(this.targetPath===null)return throwNullException("this.targetPath");return this.targetPath.Equals(otherDivert.targetPath)}}}return false}toString(){if(this.hasVariableTarget){return"Divert(variable: "+this.variableDivertName+")"}else if(this.targetPath==null){return"Divert(null)"}else{let sb=new StringBuilder;let targetStr=this.targetPath.toString();sb.Append("Divert");if(this.isConditional)sb.Append("?");if(this.pushesToStack){if(this.stackPushType==PushPopType.Function){sb.Append(" function")}else{sb.Append(" tunnel")}}sb.Append(" -> ");sb.Append(this.targetPathString);sb.Append(" (");sb.Append(targetStr);sb.Append(")");return sb.toString()}}}class ChoicePoint extends InkObject{constructor(onceOnly=true){super();this._pathOnChoice=null;this.hasCondition=false;this.hasStartContent=false;this.hasChoiceOnlyContent=false;this.isInvisibleDefault=false;this.onceOnly=true;this.onceOnly=onceOnly}get pathOnChoice(){if(this._pathOnChoice!=null&&this._pathOnChoice.isRelative){let choiceTargetObj=this.choiceTarget;if(choiceTargetObj){this._pathOnChoice=choiceTargetObj.path}}return this._pathOnChoice}set pathOnChoice(value){this._pathOnChoice=value}get choiceTarget(){if(this._pathOnChoice===null)return throwNullException("ChoicePoint._pathOnChoice");return this.ResolvePath(this._pathOnChoice).container}get pathStringOnChoice(){if(this.pathOnChoice===null)return throwNullException("ChoicePoint.pathOnChoice");return this.CompactPathString(this.pathOnChoice)}set pathStringOnChoice(value){this.pathOnChoice=new Path(value)}get flags(){let flags=0;if(this.hasCondition)flags|=1;if(this.hasStartContent)flags|=2;if(this.hasChoiceOnlyContent)flags|=4;if(this.isInvisibleDefault)flags|=8;if(this.onceOnly)flags|=16;return flags}set flags(value){this.hasCondition=(value&1)>0;this.hasStartContent=(value&2)>0;this.hasChoiceOnlyContent=(value&4)>0;this.isInvisibleDefault=(value&8)>0;this.onceOnly=(value&16)>0}toString(){if(this.pathOnChoice===null)return throwNullException("ChoicePoint.pathOnChoice");let targetString=this.pathOnChoice.toString();return"Choice: -> "+targetString}}class VariableReference extends InkObject{constructor(name=null){super();this.pathForCount=null;this.name=name}get containerForCount(){if(this.pathForCount===null)return null;return this.ResolvePath(this.pathForCount).container}get pathStringForCount(){if(this.pathForCount===null)return null;return this.CompactPathString(this.pathForCount)}set pathStringForCount(value){if(value===null)this.pathForCount=null;else this.pathForCount=new Path(value)}toString(){if(this.name!=null){return"var("+this.name+")"}else{let pathStr=this.pathStringForCount;return"read_count("+pathStr+")"}}}class VariableAssignment extends InkObject{constructor(variableName,isNewDeclaration){super();this.variableName=variableName||null;this.isNewDeclaration=!!isNewDeclaration;this.isGlobal=false}toString(){return"VarAssign to "+this.variableName}}class Void extends InkObject{}class NativeFunctionCall extends InkObject{constructor(){super();this._name=null;this._numberOfParameters=0;this._prototype=null;this._isPrototype=false;this._operationFuncs=null;if(arguments.length===0){NativeFunctionCall.GenerateNativeFunctionsIfNecessary()}else if(arguments.length===1){let name=arguments[0];NativeFunctionCall.GenerateNativeFunctionsIfNecessary();this.name=name}else if(arguments.length===2){let name=arguments[0];let numberOfParameters=arguments[1];this._isPrototype=true;this.name=name;this.numberOfParameters=numberOfParameters}}static CallWithName(functionName){return new NativeFunctionCall(functionName)}static CallExistsWithName(functionName){this.GenerateNativeFunctionsIfNecessary();return this._nativeFunctions.get(functionName)}get name(){if(this._name===null)return throwNullException("NativeFunctionCall._name");return this._name}set name(value){this._name=value;if(!this._isPrototype){if(NativeFunctionCall._nativeFunctions===null)throwNullException("NativeFunctionCall._nativeFunctions");else this._prototype=NativeFunctionCall._nativeFunctions.get(this._name)||null}}get numberOfParameters(){if(this._prototype){return this._prototype.numberOfParameters}else{return this._numberOfParameters}}set numberOfParameters(value){this._numberOfParameters=value}Call(parameters){if(this._prototype){return this._prototype.Call(parameters)}if(this.numberOfParameters!=parameters.length){throw new Error("Unexpected number of parameters")}let hasList=false;for(let p of parameters){if(p instanceof Void)throw new StoryException('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');if(p instanceof ListValue)hasList=true}if(parameters.length==2&&hasList){return this.CallBinaryListOperation(parameters)}let coercedParams=this.CoerceValuesToSingleType(parameters);let coercedType=coercedParams[0].valueType;if(coercedType==ValueType.Int){return this.CallType(coercedParams)}else if(coercedType==ValueType.Float){return this.CallType(coercedParams)}else if(coercedType==ValueType.String){return this.CallType(coercedParams)}else if(coercedType==ValueType.DivertTarget){return this.CallType(coercedParams)}else if(coercedType==ValueType.List){return this.CallType(coercedParams)}return null}CallType(parametersOfSingleType){let param1=asOrThrows(parametersOfSingleType[0],Value);let valType=param1.valueType;let val1=param1;let paramCount=parametersOfSingleType.length;if(paramCount==2||paramCount==1){if(this._operationFuncs===null)return throwNullException("NativeFunctionCall._operationFuncs");let opForTypeObj=this._operationFuncs.get(valType);if(!opForTypeObj){throw new StoryException("Cannot perform operation "+this.name+" on "+valType)}if(paramCount==2){let param2=asOrThrows(parametersOfSingleType[1],Value);let val2=param2;let opForType=opForTypeObj;if(val1.value===null||val2.value===null)return throwNullException("NativeFunctionCall.Call BinaryOp values");let resultVal=opForType(val1.value,val2.value);return Value.Create(resultVal)}else{let opForType=opForTypeObj;if(val1.value===null)return throwNullException("NativeFunctionCall.Call UnaryOp value");let resultVal=opForType(val1.value);return Value.Create(resultVal)}}else{throw new Error("Unexpected number of parameters to NativeFunctionCall: "+parametersOfSingleType.length)}}CallBinaryListOperation(parameters){if((this.name=="+"||this.name=="-")&&parameters[0]instanceof ListValue&&parameters[1]instanceof IntValue)return this.CallListIncrementOperation(parameters);let v1=asOrThrows(parameters[0],Value);let v2=asOrThrows(parameters[1],Value);if((this.name=="&&"||this.name=="||")&&(v1.valueType!=ValueType.List||v2.valueType!=ValueType.List)){if(this._operationFuncs===null)return throwNullException("NativeFunctionCall._operationFuncs");let op=this._operationFuncs.get(ValueType.Int);if(op===null)return throwNullException("NativeFunctionCall.CallBinaryListOperation op");let result=op(v1.isTruthy?1:0,v2.isTruthy?1:0);return new IntValue(result)}if(v1.valueType==ValueType.List&&v2.valueType==ValueType.List)return this.CallType([v1,v2]);throw new StoryException("Can not call use "+this.name+" operation on "+v1.valueType+" and "+v2.valueType)}CallListIncrementOperation(listIntParams){let listVal=asOrThrows(listIntParams[0],ListValue);let intVal=asOrThrows(listIntParams[1],IntValue);let resultInkList=new InkList;if(listVal.value===null)return throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value");for(let[listItemKey,listItemValue]of listVal.value){let listItem=InkListItem.fromSerializedKey(listItemKey);if(this._operationFuncs===null)return throwNullException("NativeFunctionCall._operationFuncs");let intOp=this._operationFuncs.get(ValueType.Int);if(intVal.value===null)return throwNullException("NativeFunctionCall.CallListIncrementOperation intVal.value");let targetInt=intOp(listItemValue,intVal.value);let itemOrigin=null;if(listVal.value.origins===null)return throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");for(let origin of listVal.value.origins){if(origin.name==listItem.originName){itemOrigin=origin;break}}if(itemOrigin!=null){let incrementedItem=itemOrigin.TryGetItemWithValue(targetInt,InkListItem.Null);if(incrementedItem.exists)resultInkList.Add(incrementedItem.result,targetInt)}}return new ListValue(resultInkList)}CoerceValuesToSingleType(parametersIn){let valType=ValueType.Int;let specialCaseList=null;for(let obj of parametersIn){let val=asOrThrows(obj,Value);if(val.valueType>valType){valType=val.valueType}if(val.valueType==ValueType.List){specialCaseList=asOrNull(val,ListValue)}}let parametersOut=[];if(ValueType[valType]==ValueType[ValueType.List]){for(let inkObjectVal of parametersIn){let val=asOrThrows(inkObjectVal,Value);if(val.valueType==ValueType.List){parametersOut.push(val)}else if(val.valueType==ValueType.Int){let intVal=parseInt(val.valueObject);specialCaseList=asOrThrows(specialCaseList,ListValue);if(specialCaseList.value===null)return throwNullException("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");let list=specialCaseList.value.originOfMaxItem;if(list===null)return throwNullException("NativeFunctionCall.CoerceValuesToSingleType list");let item=list.TryGetItemWithValue(intVal,InkListItem.Null);if(item.exists){let castedValue=new ListValue(item.result,intVal);parametersOut.push(castedValue)}else throw new StoryException("Could not find List item with the value "+intVal+" in "+list.name)}else throw new StoryException("Cannot mix Lists and "+val.valueType+" values in this operation")}}else{for(let inkObjectVal of parametersIn){let val=asOrThrows(inkObjectVal,Value);let castedValue=val.Cast(valType);parametersOut.push(castedValue)}}return parametersOut}static Identity(t){return t}static GenerateNativeFunctionsIfNecessary(){if(this._nativeFunctions==null){this._nativeFunctions=new Map;this.AddIntBinaryOp(this.Add,(x,y)=>x+y);this.AddIntBinaryOp(this.Subtract,(x,y)=>x-y);this.AddIntBinaryOp(this.Multiply,(x,y)=>x*y);this.AddIntBinaryOp(this.Divide,(x,y)=>Math.round(x/y));this.AddIntBinaryOp(this.Mod,(x,y)=>x%y);this.AddIntUnaryOp(this.Negate,x=>-x);this.AddIntBinaryOp(this.Equal,(x,y)=>x==y?1:0);this.AddIntBinaryOp(this.Greater,(x,y)=>x>y?1:0);this.AddIntBinaryOp(this.Less,(x,y)=>x<y?1:0);this.AddIntBinaryOp(this.GreaterThanOrEquals,(x,y)=>x>=y?1:0);this.AddIntBinaryOp(this.LessThanOrEquals,(x,y)=>x<=y?1:0);this.AddIntBinaryOp(this.NotEquals,(x,y)=>x!=y?1:0);this.AddIntUnaryOp(this.Not,x=>x==0?1:0);this.AddIntBinaryOp(this.And,(x,y)=>x!=0&&y!=0?1:0);this.AddIntBinaryOp(this.Or,(x,y)=>x!=0||y!=0?1:0);this.AddIntBinaryOp(this.Max,(x,y)=>Math.max(x,y));this.AddIntBinaryOp(this.Min,(x,y)=>Math.min(x,y));this.AddIntBinaryOp(this.Pow,(x,y)=>Math.pow(x,y));this.AddIntUnaryOp(this.Floor,NativeFunctionCall.Identity);this.AddIntUnaryOp(this.Ceiling,NativeFunctionCall.Identity);this.AddIntUnaryOp(this.Int,NativeFunctionCall.Identity);this.AddIntUnaryOp(this.Float,x=>x);this.AddFloatBinaryOp(this.Add,(x,y)=>x+y);this.AddFloatBinaryOp(this.Subtract,(x,y)=>x-y);this.AddFloatBinaryOp(this.Multiply,(x,y)=>x*y);this.AddFloatBinaryOp(this.Divide,(x,y)=>x/y);this.AddFloatBinaryOp(this.Mod,(x,y)=>x%y);this.AddFloatUnaryOp(this.Negate,x=>-x);this.AddFloatBinaryOp(this.Equal,(x,y)=>x==y?1:0);this.AddFloatBinaryOp(this.Greater,(x,y)=>x>y?1:0);this.AddFloatBinaryOp(this.Less,(x,y)=>x<y?1:0);this.AddFloatBinaryOp(this.GreaterThanOrEquals,(x,y)=>x>=y?1:0);this.AddFloatBinaryOp(this.LessThanOrEquals,(x,y)=>x<=y?1:0);this.AddFloatBinaryOp(this.NotEquals,(x,y)=>x!=y?1:0);this.AddFloatUnaryOp(this.Not,x=>x==0?1:0);this.AddFloatBinaryOp(this.And,(x,y)=>x!=0&&y!=0?1:0);this.AddFloatBinaryOp(this.Or,(x,y)=>x!=0||y!=0?1:0);this.AddFloatBinaryOp(this.Max,(x,y)=>Math.max(x,y));this.AddFloatBinaryOp(this.Min,(x,y)=>Math.min(x,y));this.AddFloatBinaryOp(this.Pow,(x,y)=>Math.pow(x,y));this.AddFloatUnaryOp(this.Floor,x=>Math.floor(x));this.AddFloatUnaryOp(this.Ceiling,x=>Math.ceil(x));this.AddFloatUnaryOp(this.Int,x=>Math.floor(x));this.AddFloatUnaryOp(this.Float,NativeFunctionCall.Identity);this.AddStringBinaryOp(this.Add,(x,y)=>x+y);this.AddStringBinaryOp(this.Equal,(x,y)=>x===y?1:0);this.AddStringBinaryOp(this.NotEquals,(x,y)=>!(x===y)?1:0);this.AddStringBinaryOp(this.Has,(x,y)=>x.includes(y)?1:0);this.AddStringBinaryOp(this.Hasnt,(x,y)=>x.includes(y)?0:1);this.AddListBinaryOp(this.Add,(x,y)=>x.Union(y));this.AddListBinaryOp(this.Subtract,(x,y)=>x.Without(y));this.AddListBinaryOp(this.Has,(x,y)=>x.Contains(y)?1:0);this.AddListBinaryOp(this.Hasnt,(x,y)=>x.Contains(y)?0:1);this.AddListBinaryOp(this.Intersect,(x,y)=>x.Intersect(y));this.AddListBinaryOp(this.Equal,(x,y)=>x.Equals(y)?1:0);this.AddListBinaryOp(this.Greater,(x,y)=>x.GreaterThan(y)?1:0);this.AddListBinaryOp(this.Less,(x,y)=>x.LessThan(y)?1:0);this.AddListBinaryOp(this.GreaterThanOrEquals,(x,y)=>x.GreaterThanOrEquals(y)?1:0);this.AddListBinaryOp(this.LessThanOrEquals,(x,y)=>x.LessThanOrEquals(y)?1:0);this.AddListBinaryOp(this.NotEquals,(x,y)=>!x.Equals(y)?1:0);this.AddListBinaryOp(this.And,(x,y)=>x.Count>0&&y.Count>0?1:0);this.AddListBinaryOp(this.Or,(x,y)=>x.Count>0||y.Count>0?1:0);this.AddListUnaryOp(this.Not,x=>x.Count==0?1:0);this.AddListUnaryOp(this.Invert,x=>x.inverse);this.AddListUnaryOp(this.All,x=>x.all);this.AddListUnaryOp(this.ListMin,x=>x.MinAsList());this.AddListUnaryOp(this.ListMax,x=>x.MaxAsList());this.AddListUnaryOp(this.Count,x=>x.Count);this.AddListUnaryOp(this.ValueOfList,x=>x.maxItem.Value);let divertTargetsEqual=(d1,d2)=>{return d1.Equals(d2)?1:0};let divertTargetsNotEqual=(d1,d2)=>{return d1.Equals(d2)?0:1};this.AddOpToNativeFunc(this.Equal,2,ValueType.DivertTarget,divertTargetsEqual);this.AddOpToNativeFunc(this.NotEquals,2,ValueType.DivertTarget,divertTargetsNotEqual)}}AddOpFuncForType(valType,op){if(this._operationFuncs==null){this._operationFuncs=new Map}this._operationFuncs.set(valType,op)}static AddOpToNativeFunc(name,args,valType,op){if(this._nativeFunctions===null)return throwNullException("NativeFunctionCall._nativeFunctions");let nativeFunc=this._nativeFunctions.get(name);if(!nativeFunc){nativeFunc=new NativeFunctionCall(name,args);this._nativeFunctions.set(name,nativeFunc)}nativeFunc.AddOpFuncForType(valType,op)}static AddIntBinaryOp(name,op){this.AddOpToNativeFunc(name,2,ValueType.Int,op)}static AddIntUnaryOp(name,op){this.AddOpToNativeFunc(name,1,ValueType.Int,op)}static AddFloatBinaryOp(name,op){this.AddOpToNativeFunc(name,2,ValueType.Float,op)}static AddFloatUnaryOp(name,op){this.AddOpToNativeFunc(name,1,ValueType.Float,op)}static AddStringBinaryOp(name,op){this.AddOpToNativeFunc(name,2,ValueType.String,op)}static AddListBinaryOp(name,op){this.AddOpToNativeFunc(name,2,ValueType.List,op)}static AddListUnaryOp(name,op){this.AddOpToNativeFunc(name,1,ValueType.List,op)}toString(){return'Native "'+this.name+'"'}}NativeFunctionCall.Add="+";NativeFunctionCall.Subtract="-";NativeFunctionCall.Divide="/";NativeFunctionCall.Multiply="*";NativeFunctionCall.Mod="%";NativeFunctionCall.Negate="_";NativeFunctionCall.Equal="==";NativeFunctionCall.Greater=">";NativeFunctionCall.Less="<";NativeFunctionCall.GreaterThanOrEquals=">=";NativeFunctionCall.LessThanOrEquals="<=";NativeFunctionCall.NotEquals="!=";NativeFunctionCall.Not="!";NativeFunctionCall.And="&&";NativeFunctionCall.Or="||";NativeFunctionCall.Min="MIN";NativeFunctionCall.Max="MAX";NativeFunctionCall.Pow="POW";NativeFunctionCall.Floor="FLOOR";NativeFunctionCall.Ceiling="CEILING";NativeFunctionCall.Int="INT";NativeFunctionCall.Float="FLOAT";NativeFunctionCall.Has="?";NativeFunctionCall.Hasnt="!?";NativeFunctionCall.Intersect="^";NativeFunctionCall.ListMin="LIST_MIN";NativeFunctionCall.ListMax="LIST_MAX";NativeFunctionCall.All="LIST_ALL";NativeFunctionCall.Count="LIST_COUNT";NativeFunctionCall.ValueOfList="LIST_VALUE";NativeFunctionCall.Invert="LIST_INVERT";NativeFunctionCall._nativeFunctions=null;class Tag extends InkObject{constructor(tagText){super();this.text=tagText.toString()||""}toString(){return"# "+this.text}}class Choice extends InkObject{constructor(){super(...arguments);this.text="";this.index=0;this.threadAtGeneration=null;this.sourcePath="";this.targetPath=null;this.isInvisibleDefault=false;this.originalThreadIndex=0}get pathStringOnChoice(){if(this.targetPath===null)return throwNullException("Choice.targetPath");return this.targetPath.toString()}set pathStringOnChoice(value){this.targetPath=new Path(value)}}class ListDefinition{constructor(name,items){this._name=name||"";this._items=null;this._itemNameToValues=items||new Map}get name(){return this._name}get items(){if(this._items==null){this._items=new Map;for(let[key,value]of this._itemNameToValues){let item=new InkListItem(this.name,key);this._items.set(item.serialized(),value)}}return this._items}ValueForItem(item){if(!item.itemName)return 0;let intVal=this._itemNameToValues.get(item.itemName);if(typeof intVal!=="undefined")return intVal;else return 0}ContainsItem(item){if(!item.itemName)return false;if(item.originName!=this.name)return false;return this._itemNameToValues.has(item.itemName)}ContainsItemWithName(itemName){return this._itemNameToValues.has(itemName)}TryGetItemWithValue(val,item){for(let[key,value]of this._itemNameToValues){if(value==val){item=new InkListItem(this.name,key);return{result:item,exists:true}}}item=InkListItem.Null;return{result:item,exists:false}}TryGetValueForItem(item,intVal){if(!item.itemName)return{result:0,exists:false};let value=this._itemNameToValues.get(item.itemName);if(!value)return{result:0,exists:false};return{result:value,exists:true}}}class ListDefinitionsOrigin{constructor(lists){this._lists=new Map;this._allUnambiguousListValueCache=new Map;for(let list of lists){this._lists.set(list.name,list);for(let[key,val]of list.items){let item=InkListItem.fromSerializedKey(key);let listValue=new ListValue(item,val);if(!item.itemName){throw new Error("item.itemName is null or undefined.")}this._allUnambiguousListValueCache.set(item.itemName,listValue);this._allUnambiguousListValueCache.set(item.fullName,listValue)}}}get lists(){let listOfLists=[];for(let[key,value]of this._lists){listOfLists.push(value)}return listOfLists}TryListGetDefinition(name,def){if(name===null){return{result:def,exists:false}}let definition=this._lists.get(name);if(!definition)return{result:def,exists:false};return{result:definition,exists:true}}FindSingleItemListWithName(name){if(name===null){return throwNullException("name")}let val=this._allUnambiguousListValueCache.get(name);if(typeof val!=="undefined"){return val}return null}}class JsonSerialisation{static ListToJArray(serialisables){let jArray=[];for(let s of serialisables){jArray.push(this.RuntimeObjectToJToken(s))}return jArray}static JArrayToRuntimeObjList(jArray,skipLast=false){let count=jArray.length;if(skipLast)count--;let list=[];for(let i=0;i<count;i++){let jTok=jArray[i];let runtimeObj=this.JTokenToRuntimeObject(jTok);if(runtimeObj===null){return throwNullException("runtimeObj")}list.push(runtimeObj)}return list}static DictionaryRuntimeObjsToJObject(dictionary){let jsonObj={};for(let[key,value]of dictionary){let runtimeObj=asOrNull(value,InkObject);if(runtimeObj!=null)jsonObj[key]=this.RuntimeObjectToJToken(runtimeObj)}return jsonObj}static JObjectToDictionaryRuntimeObjs(jObject){let dict=new Map;for(let key in jObject){if(jObject.hasOwnProperty(key)){let inkObject=this.JTokenToRuntimeObject(jObject[key]);if(inkObject===null){return throwNullException("inkObject")}dict.set(key,inkObject)}}return dict}static JObjectToIntDictionary(jObject){let dict=new Map;for(let key in jObject){if(jObject.hasOwnProperty(key)){dict.set(key,parseInt(jObject[key]))}}return dict}static IntDictionaryToJObject(dict){let jObj={};for(let[key,value]of dict){jObj[key]=asNumberOrThrows(value)}return jObj}static JTokenToRuntimeObject(token){if(typeof token==="number"&&!isNaN(token)){return Value.Create(token)}if(typeof token==="string"){let str=token.toString();let firstChar=str[0];if(firstChar=="^")return new StringValue(str.substring(1));else if(firstChar=="\n"&&str.length==1)return new StringValue("\n");if(str=="<>")return new Glue;for(let i=0;i<JsonSerialisation._controlCommandNames.length;++i){let cmdName=JsonSerialisation._controlCommandNames[i];if(str==cmdName){return new ControlCommand(i)}}if(str=="L^")str="^";if(NativeFunctionCall.CallExistsWithName(str))return NativeFunctionCall.CallWithName(str);if(str=="->->")return ControlCommand.PopTunnel();else if(str=="~ret")return ControlCommand.PopFunction();if(str=="void")return new Void}if(typeof token==="object"&&token instanceof Array===false){let obj=token;let propValue;if(obj["^->"]){propValue=obj["^->"];return new DivertTargetValue(new Path(propValue.toString()))}if(obj["^var"]){propValue=obj["^var"];let varPtr=new VariablePointerValue(propValue.toString());if("ci"in obj){propValue=obj["ci"];varPtr.contextIndex=parseInt(propValue)}return varPtr}let isDivert=false;let pushesToStack=false;let divPushType=PushPopType.Function;let external=false;if(propValue=obj["->"]){isDivert=true}else if(propValue=obj["f()"]){isDivert=true;pushesToStack=true;divPushType=PushPopType.Function}else if(propValue=obj["->t->"]){isDivert=true;pushesToStack=true;divPushType=PushPopType.Tunnel}else if(propValue=obj["x()"]){isDivert=true;external=true;pushesToStack=false;divPushType=PushPopType.Function}if(isDivert){let divert=new Divert;divert.pushesToStack=pushesToStack;divert.stackPushType=divPushType;divert.isExternal=external;let target=propValue.toString();if(propValue=obj["var"])divert.variableDivertName=target;else divert.targetPathString=target;divert.isConditional=!!obj["c"];if(external){if(propValue=obj["exArgs"])divert.externalArgs=parseInt(propValue)}return divert}if(propValue=obj["*"]){let choice=new ChoicePoint;choice.pathStringOnChoice=propValue.toString();if(propValue=obj["flg"])choice.flags=parseInt(propValue);return choice}if(propValue=obj["VAR?"]){return new VariableReference(propValue.toString())}else if(propValue=obj["CNT?"]){let readCountVarRef=new VariableReference;readCountVarRef.pathStringForCount=propValue.toString();return readCountVarRef}let isVarAss=false;let isGlobalVar=false;if(propValue=obj["VAR="]){isVarAss=true;isGlobalVar=true}else if(propValue=obj["temp="]){isVarAss=true;isGlobalVar=false}if(isVarAss){let varName=propValue.toString();let isNewDecl=!obj["re"];let varAss=new VariableAssignment(varName,isNewDecl);varAss.isGlobal=isGlobalVar;return varAss}if(obj["#"]!==undefined){propValue=obj["#"];return new Tag(propValue.toString())}if(propValue=obj["list"]){let listContent=propValue;let rawList=new InkList;if(propValue=obj["origins"]){let namesAsObjs=propValue;rawList.SetInitialOriginNames(namesAsObjs)}for(let key in listContent){if(listContent.hasOwnProperty(key)){let nameToVal=listContent[key];let item=new InkListItem(key);let val=parseInt(nameToVal);rawList.Add(item,val)}}return new ListValue(rawList)}if(obj["originalChoicePath"]!=null)return this.JObjectToChoice(obj)}if(token instanceof Array){return this.JArrayToContainer(token)}if(token===null||token===undefined)return null;throw new Error("Failed to convert token to runtime object: "+JSON.stringify(token))}static RuntimeObjectToJToken(obj){let container=asOrNull(obj,Container);if(container){return this.ContainerToJArray(container)}let divert=asOrNull(obj,Divert);if(divert){let divTypeKey="->";if(divert.isExternal)divTypeKey="x()";else if(divert.pushesToStack){if(divert.stackPushType==PushPopType.Function)divTypeKey="f()";else if(divert.stackPushType==PushPopType.Tunnel)divTypeKey="->t->"}let targetStr;if(divert.hasVariableTarget)targetStr=divert.variableDivertName;else targetStr=divert.targetPathString;let jObj={};jObj[divTypeKey]=targetStr;if(divert.hasVariableTarget)jObj["var"]=true;if(divert.isConditional)jObj["c"]=true;if(divert.externalArgs>0)jObj["exArgs"]=divert.externalArgs;return jObj}let choicePoint=asOrNull(obj,ChoicePoint);if(choicePoint){let jObj={};jObj["*"]=choicePoint.pathStringOnChoice;jObj["flg"]=choicePoint.flags;return jObj}let intVal=asOrNull(obj,IntValue);if(intVal)return intVal.value;let floatVal=asOrNull(obj,FloatValue);if(floatVal)return floatVal.value;let strVal=asOrNull(obj,StringValue);if(strVal){if(strVal.isNewline)return"\n";else return"^"+strVal.value}let listVal=asOrNull(obj,ListValue);if(listVal){return this.InkListToJObject(listVal)}let divTargetVal=asOrNull(obj,DivertTargetValue);if(divTargetVal){let divTargetJsonObj={};if(divTargetVal.value===null){return throwNullException("divTargetVal.value")}divTargetJsonObj["^->"]=divTargetVal.value.componentsString;return divTargetJsonObj}let varPtrVal=asOrNull(obj,VariablePointerValue);if(varPtrVal){let varPtrJsonObj={};varPtrJsonObj["^var"]=varPtrVal.value;varPtrJsonObj["ci"]=varPtrVal.contextIndex;return varPtrJsonObj}let glue=asOrNull(obj,Glue);if(glue)return"<>";let controlCmd=asOrNull(obj,ControlCommand);if(controlCmd){return JsonSerialisation._controlCommandNames[controlCmd.commandType]}let nativeFunc=asOrNull(obj,NativeFunctionCall);if(nativeFunc){let name=nativeFunc.name;if(name=="^")name="L^";return name}let varRef=asOrNull(obj,VariableReference);if(varRef){let jObj={};let readCountPath=varRef.pathStringForCount;if(readCountPath!=null){jObj["CNT?"]=readCountPath}else{jObj["VAR?"]=varRef.name}return jObj}let varAss=asOrNull(obj,VariableAssignment);if(varAss){let key=varAss.isGlobal?"VAR=":"temp=";let jObj={};jObj[key]=varAss.variableName;if(!varAss.isNewDeclaration)jObj["re"]=true;return jObj}let voidObj=asOrNull(obj,Void);if(voidObj)return"void";let tag=asOrNull(obj,Tag);if(tag){let jObj={};jObj["#"]=tag.text;return jObj}let choice=asOrNull(obj,Choice);if(choice)return this.ChoiceToJObject(choice);throw new Error("Failed to convert runtime object to Json token: "+obj)}static ContainerToJArray(container){let jArray=this.ListToJArray(container.content);let namedOnlyContent=container.namedOnlyContent;let countFlags=container.countFlags;if(namedOnlyContent!=null&&namedOnlyContent.size>0||countFlags>0||container.name!=null){let terminatingObj;if(namedOnlyContent!=null){terminatingObj=this.DictionaryRuntimeObjsToJObject(namedOnlyContent);for(let key in terminatingObj){if(terminatingObj.hasOwnProperty(key)){let subContainerJArray=terminatingObj[key];if(subContainerJArray!=null){let attrJObj=subContainerJArray[subContainerJArray.length-1];if(attrJObj!=null){delete attrJObj["#n"];if(Object.keys(attrJObj).length==0)subContainerJArray[subContainerJArray.length-1]=null}}}}}else terminatingObj={};if(countFlags>0)terminatingObj["#f"]=countFlags;if(container.name!=null)terminatingObj["#n"]=container.name;jArray.push(terminatingObj)}else{jArray.push(null)}return jArray}static JArrayToContainer(jArray){let container=new Container;container.content=this.JArrayToRuntimeObjList(jArray,true);let terminatingObj=jArray[jArray.length-1];if(terminatingObj!=null){let namedOnlyContent=new Map;for(let key in terminatingObj){if(key=="#f"){container.countFlags=parseInt(terminatingObj[key])}else if(key=="#n"){container.name=terminatingObj[key].toString()}else{let namedContentItem=this.JTokenToRuntimeObject(terminatingObj[key]);let namedSubContainer=asOrNull(namedContentItem,Container);if(namedSubContainer)namedSubContainer.name=key;namedOnlyContent.set(key,namedContentItem)}}container.namedOnlyContent=namedOnlyContent}return container}static JObjectToChoice(jObj){let choice=new Choice;choice.text=jObj["text"].toString();choice.index=parseInt(jObj["index"]);choice.sourcePath=jObj["originalChoicePath"].toString();choice.originalThreadIndex=parseInt(jObj["originalThreadIndex"]);choice.pathStringOnChoice=jObj["targetPath"].toString();return choice}static ChoiceToJObject(choice){let jObj={};jObj["text"]=choice.text;jObj["index"]=choice.index;jObj["originalChoicePath"]=choice.sourcePath;jObj["originalThreadIndex"]=choice.originalThreadIndex;jObj["targetPath"]=choice.pathStringOnChoice;return jObj}static InkListToJObject(listVal){let rawList=listVal.value;if(rawList===null){return throwNullException("rawList")}let dict={};let content={};for(let[key,val]of rawList){let item=InkListItem.fromSerializedKey(key);content[item.toString()]=val}dict["list"]=content;if(rawList.Count==0&&rawList.originNames!=null&&rawList.originNames.length>0){dict["origins"]=rawList.originNames}return dict}static ListDefinitionsToJToken(origin){let result={};for(let def of origin.lists){let listDefJson={};for(let[key,val]of def.items){let item=InkListItem.fromSerializedKey(key);if(item.itemName===null){return throwNullException("item.itemName")}listDefJson[item.itemName]=val}result[def.name]=listDefJson}return result}static JTokenToListDefinitions(obj){let defsObj=obj;let allDefs=[];for(let key in defsObj){if(defsObj.hasOwnProperty(key)){let name=key.toString();let listDefJson=defsObj[key];let items=new Map;for(let nameValueKey in listDefJson){if(defsObj.hasOwnProperty(key)){let nameValue=listDefJson[nameValueKey];items.set(nameValueKey,parseInt(nameValue))}}let def=new ListDefinition(name,items);allDefs.push(def)}}return new ListDefinitionsOrigin(allDefs)}}JsonSerialisation._controlCommandNames=(()=>{let _controlCommandNames=[];_controlCommandNames[ControlCommand.CommandType.EvalStart]="ev";_controlCommandNames[ControlCommand.CommandType.EvalOutput]="out";_controlCommandNames[ControlCommand.CommandType.EvalEnd]="/ev";_controlCommandNames[ControlCommand.CommandType.Duplicate]="du";_controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue]="pop";_controlCommandNames[ControlCommand.CommandType.PopFunction]="~ret";_controlCommandNames[ControlCommand.CommandType.PopTunnel]="->->";_controlCommandNames[ControlCommand.CommandType.BeginString]="str";_controlCommandNames[ControlCommand.CommandType.EndString]="/str";_controlCommandNames[ControlCommand.CommandType.NoOp]="nop";_controlCommandNames[ControlCommand.CommandType.ChoiceCount]="choiceCnt";_controlCommandNames[ControlCommand.CommandType.Turns]="turn";_controlCommandNames[ControlCommand.CommandType.TurnsSince]="turns";_controlCommandNames[ControlCommand.CommandType.ReadCount]="readc";_controlCommandNames[ControlCommand.CommandType.Random]="rnd";_controlCommandNames[ControlCommand.CommandType.SeedRandom]="srnd";_controlCommandNames[ControlCommand.CommandType.VisitIndex]="visit";_controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex]="seq";_controlCommandNames[ControlCommand.CommandType.StartThread]="thread";_controlCommandNames[ControlCommand.CommandType.Done]="done";_controlCommandNames[ControlCommand.CommandType.End]="end";_controlCommandNames[ControlCommand.CommandType.ListFromInt]="listInt";_controlCommandNames[ControlCommand.CommandType.ListRange]="range";_controlCommandNames[ControlCommand.CommandType.ListRandom]="lrnd";for(let i=0;i<ControlCommand.CommandType.TOTAL_VALUES;++i){if(_controlCommandNames[i]==null)throw new Error("Control command not accounted for in serialisation")}return _controlCommandNames})();class CallStack{constructor(){this._threadCounter=0;if(arguments[0]instanceof Container||arguments[0]===null){let rootContentContainer=arguments[0];this._threads=[];this._threads.push(new CallStack.Thread);this._threads[0].callstack.push(new CallStack.Element(PushPopType.Tunnel,Pointer.StartOf(rootContentContainer)))}else{let toCopy=arguments[0];this._threads=[];for(let otherThread of toCopy._threads){this._threads.push(otherThread.Copy())}}}get elements(){return this.callStack}get depth(){return this.elements.length}get currentElement(){let thread=this._threads[this._threads.length-1];let cs=thread.callstack;return cs[cs.length-1]}get currentElementIndex(){return this.callStack.length-1}get currentThread(){return this._threads[this._threads.length-1]}set currentThread(value){Debug.Assert(this._threads.length==1,"Shouldn't be directly setting the current thread when we have a stack of them");this._threads.length=0;this._threads.push(value)}get canPop(){return this.callStack.length>1}SetJsonToken(jObject,storyContext){this._threads.length=0;let jThreads=jObject["threads"];for(let jThreadTok of jThreads){let jThreadObj=jThreadTok;let thread=new CallStack.Thread(jThreadObj,storyContext);this._threads.push(thread)}this._threadCounter=parseInt(jObject["threadCounter"])}GetJsonToken(){let jObject={};let jThreads=[];for(let thread of this._threads){jThreads.push(thread.jsonToken)}jObject["threads"]=jThreads;jObject["threadCounter"]=this._threadCounter;return jObject}PushThread(){let newThread=this.currentThread.Copy();this._threadCounter++;newThread.threadIndex=this._threadCounter;this._threads.push(newThread)}PopThread(){if(this.canPopThread){this._threads.splice(this._threads.indexOf(this.currentThread),1)}else{throw new Error("Can't pop thread")}}get canPopThread(){return this._threads.length>1&&!this.elementIsEvaluateFromGame}get elementIsEvaluateFromGame(){return this.currentElement.type==PushPopType.FunctionEvaluationFromGame}Push(type,externalEvaluationStackHeight=0,outputStreamLengthWithPushed=0){let element=new CallStack.Element(type,this.currentElement.currentPointer,false);element.evaluationStackHeightWhenPushed=externalEvaluationStackHeight;element.functionStartInOutputStream=outputStreamLengthWithPushed;this.callStack.push(element)}CanPop(type=null){if(!this.canPop)return false;if(type==null)return true;return this.currentElement.type==type}Pop(type=null){if(this.CanPop(type)){this.callStack.pop();return}else{throw new Error("Mismatched push/pop in Callstack")}}GetTemporaryVariableWithName(name,contextIndex=-1){if(contextIndex==-1)contextIndex=this.currentElementIndex+1;let contextElement=this.callStack[contextIndex-1];let varValue=tryGetValueFromMap(contextElement.temporaryVariables,name,null);if(varValue.exists){return varValue.result}else{return null}}SetTemporaryVariable(name,value,declareNew,contextIndex=-1){if(contextIndex==-1)contextIndex=this.currentElementIndex+1;let contextElement=this.callStack[contextIndex-1];if(!declareNew&&!contextElement.temporaryVariables.get(name)){throw new StoryException("Could not find temporary variable to set: "+name)}let oldValue=tryGetValueFromMap(contextElement.temporaryVariables,name,null);if(oldValue.exists)ListValue.RetainListOriginsForAssignment(oldValue.result,value);contextElement.temporaryVariables.set(name,value)}ContextForVariableNamed(name){if(this.currentElement.temporaryVariables.get(name)){return this.currentElementIndex+1}else{return 0}}ThreadWithIndex(index){let filtered=this._threads.filter(t=>{if(t.threadIndex==index)return t});return filtered[0]}get callStack(){return this.currentThread.callstack}get callStackTrace(){let sb=new StringBuilder;for(let t=0;t<this._threads.length;t++){let thread=this._threads[t];let isCurrent=t==this._threads.length-1;sb.AppendFormat("=== THREAD {0}/{1} {2}===\n",t+1,this._threads.length,isCurrent?"(current) ":"");for(let i=0;i<thread.callstack.length;i++){if(thread.callstack[i].type==PushPopType.Function)sb.Append("  [FUNCTION] ");else sb.Append("  [TUNNEL] ");let pointer=thread.callstack[i].currentPointer;if(!pointer.isNull){sb.Append("<SOMEWHERE IN ");if(pointer.container===null){return throwNullException("pointer.container")}sb.Append(pointer.container.path.toString());sb.AppendLine(">")}}}return sb.toString()}}(function(CallStack){class Element{constructor(type,pointer,inExpressionEvaluation=false){this.evaluationStackHeightWhenPushed=0;this.functionStartInOutputStream=0;this.currentPointer=pointer.copy();this.inExpressionEvaluation=inExpressionEvaluation;this.temporaryVariables=new Map;this.type=type}Copy(){let copy=new Element(this.type,this.currentPointer,this.inExpressionEvaluation);copy.temporaryVariables=new Map(this.temporaryVariables);copy.evaluationStackHeightWhenPushed=this.evaluationStackHeightWhenPushed;copy.functionStartInOutputStream=this.functionStartInOutputStream;return copy}}CallStack.Element=Element;class Thread{constructor(){this.threadIndex=0;this.previousPointer=Pointer.Null;this.callstack=[];if(arguments[0]&&arguments[1]){let jThreadObj=arguments[0];let storyContext=arguments[1];this.threadIndex=parseInt(jThreadObj["threadIndex"]);let jThreadCallstack=jThreadObj["callstack"];for(let jElTok of jThreadCallstack){let jElementObj=jElTok;let pushPopType=parseInt(jElementObj["type"]);let pointer=Pointer.Null;let currentContainerPathStr;let currentContainerPathStrToken=jElementObj["cPath"];if(typeof currentContainerPathStrToken!=="undefined"){currentContainerPathStr=currentContainerPathStrToken.toString();let threadPointerResult=storyContext.ContentAtPath(new Path(currentContainerPathStr));pointer.container=threadPointerResult.container;pointer.index=parseInt(jElementObj["idx"]);if(threadPointerResult.obj==null)throw new Error("When loading state, internal story location couldn't be found: "+currentContainerPathStr+". Has the story changed since this save data was created?");else if(threadPointerResult.approximate){if(pointer.container===null){return throwNullException("pointer.container")}storyContext.Warning("When loading state, exact internal story location couldn't be found: '"+currentContainerPathStr+"', so it was approximated to '"+pointer.container.path.toString()+"' to recover. Has the story changed since this save data was created?")}}let inExpressionEvaluation=!!jElementObj["exp"];let el=new Element(pushPopType,pointer,inExpressionEvaluation);let jObjTemps=jElementObj["temp"];el.temporaryVariables=JsonSerialisation.JObjectToDictionaryRuntimeObjs(jObjTemps);this.callstack.push(el)}let prevContentObjPath=jThreadObj["previousContentObject"];if(typeof prevContentObjPath!=="undefined"){let prevPath=new Path(prevContentObjPath.toString());this.previousPointer=storyContext.PointerAtPath(prevPath)}}}Copy(){let copy=new Thread;copy.threadIndex=this.threadIndex;for(let e of this.callstack){copy.callstack.push(e.Copy())}copy.previousPointer=this.previousPointer.copy();return copy}get jsonToken(){let threadJObj={};let jThreadCallstack=[];for(let el of this.callstack){let jObj={};if(!el.currentPointer.isNull){if(el.currentPointer.container===null){return throwNullException("el.currentPointer.container")}jObj["cPath"]=el.currentPointer.container.path.componentsString;jObj["idx"]=el.currentPointer.index}jObj["exp"]=el.inExpressionEvaluation;jObj["type"]=el.type;jObj["temp"]=JsonSerialisation.DictionaryRuntimeObjsToJObject(el.temporaryVariables);jThreadCallstack.push(jObj)}threadJObj["callstack"]=jThreadCallstack;threadJObj["threadIndex"]=this.threadIndex;if(!this.previousPointer.isNull){let resolvedPointer=this.previousPointer.Resolve();if(resolvedPointer===null){return throwNullException("this.previousPointer.Resolve()")}threadJObj["previousContentObject"]=resolvedPointer.path.toString()}return threadJObj}}CallStack.Thread=Thread})(CallStack||(CallStack={}));class VariablesState{constructor(callStack,listDefsOrigin){this.variableChangedEventCallbacks=[];this._batchObservingVariableChanges=false;this._defaultGlobalVariables=new Map;this._changedVariables=new Set;this._globalVariables=new Map;this._callStack=callStack;this._listDefsOrigin=listDefsOrigin;try{let p=new Proxy(this,{get(target,name){return name in target?target[name]:target.$(name)},set(target,name,value){if(name in target)target[name]=value;else target.$(name,value);return true}});return p}catch(e){}}variableChangedEvent(variableName,newValue){for(let callback of this.variableChangedEventCallbacks){callback(variableName,newValue)}}get batchObservingVariableChanges(){return this._batchObservingVariableChanges}set batchObservingVariableChanges(value){this._batchObservingVariableChanges=value;if(value){this._changedVariables=new Set}else{if(this._changedVariables!=null){for(let variableName of this._changedVariables){let currentValue=this._globalVariables.get(variableName);if(!currentValue){throwNullException("currentValue")}else{this.variableChangedEvent(variableName,currentValue)}}}}}get callStack(){return this._callStack}set callStack(callStack){this._callStack=callStack}$(variableName,value){if(typeof value==="undefined"){let varContents=this._globalVariables.get(variableName);if(typeof varContents==="undefined"){varContents=this._defaultGlobalVariables.get(variableName)}if(typeof varContents!=="undefined")return varContents.valueObject;else return null}else{if(typeof this._defaultGlobalVariables.get(variableName)==="undefined")throw new StoryException("Cannot assign to a variable ("+variableName+") that hasn't been declared in the story");let val=Value.Create(value);if(val==null){if(value==null){throw new StoryException("Cannot pass null to VariableState")}else{throw new StoryException("Invalid value passed to VariableState: "+value.toString())}}this.SetGlobal(variableName,val)}}CopyFrom(toCopy){this._globalVariables=new Map(toCopy._globalVariables);this._defaultGlobalVariables=new Map(toCopy._defaultGlobalVariables);this.variableChangedEvent=toCopy.variableChangedEvent;if(toCopy.batchObservingVariableChanges!=this.batchObservingVariableChanges){if(toCopy.batchObservingVariableChanges){this._batchObservingVariableChanges=true;if(toCopy._changedVariables===null){return throwNullException("toCopy._changedVariables")}this._changedVariables=new Set(toCopy._changedVariables)}else{this._batchObservingVariableChanges=false;this._changedVariables=null}}}get jsonToken(){return JsonSerialisation.DictionaryRuntimeObjsToJObject(this._globalVariables)}set jsonToken(value){this._globalVariables=JsonSerialisation.JObjectToDictionaryRuntimeObjs(value)}TryGetDefaultVariableValue(name){let val=tryGetValueFromMap(this._defaultGlobalVariables,name,null);return val.exists?val.result:null}GlobalVariableExistsWithName(name){return this._globalVariables.has(name)}GetVariableWithName(name,contextIndex=-1){let varValue=this.GetRawVariableWithName(name,contextIndex);let varPointer=asOrNull(varValue,VariablePointerValue);if(varPointer!==null){varValue=this.ValueAtVariablePointer(varPointer)}return varValue}GetRawVariableWithName(name,contextIndex){let varValue=null;if(contextIndex==0||contextIndex==-1){let variableValue=tryGetValueFromMap(this._globalVariables,name,null);if(variableValue.exists)return variableValue.result;if(this._listDefsOrigin===null)return throwNullException("VariablesState._listDefsOrigin");let listItemValue=this._listDefsOrigin.FindSingleItemListWithName(name);if(listItemValue)return listItemValue}varValue=this._callStack.GetTemporaryVariableWithName(name,contextIndex);return varValue}ValueAtVariablePointer(pointer){return this.GetVariableWithName(pointer.variableName,pointer.contextIndex)}Assign(varAss,value){let name=varAss.variableName;if(name===null){return throwNullException("name")}let contextIndex=-1;let setGlobal=false;if(varAss.isNewDeclaration){setGlobal=varAss.isGlobal}else{setGlobal=this._globalVariables.has(name)}if(varAss.isNewDeclaration){let varPointer=asOrNull(value,VariablePointerValue);if(varPointer!==null){let fullyResolvedVariablePointer=this.ResolveVariablePointer(varPointer);value=fullyResolvedVariablePointer}}else{let existingPointer=null;do{existingPointer=asOrNull(this.GetRawVariableWithName(name,contextIndex),VariablePointerValue);if(existingPointer!=null){name=existingPointer.variableName;contextIndex=existingPointer.contextIndex;setGlobal=contextIndex==0}}while(existingPointer!=null)}if(setGlobal){this.SetGlobal(name,value)}else{this._callStack.SetTemporaryVariable(name,value,varAss.isNewDeclaration,contextIndex)}}SnapshotDefaultGlobals(){this._defaultGlobalVariables=new Map(this._globalVariables)}RetainListOriginsForAssignment(oldValue,newValue){let oldList=asOrThrows(oldValue,ListValue);let newList=asOrThrows(newValue,ListValue);if(oldList.value&&newList.value&&newList.value.Count==0){newList.value.SetInitialOriginNames(oldList.value.originNames)}}SetGlobal(variableName,value){let oldValue=tryGetValueFromMap(this._globalVariables,variableName,null);if(oldValue.exists){ListValue.RetainListOriginsForAssignment(oldValue.result,value)}if(variableName===null){return throwNullException("variableName")}this._globalVariables.set(variableName,value);if(this.variableChangedEvent!=null&&value!==oldValue.result){if(this.batchObservingVariableChanges){if(this._changedVariables===null){return throwNullException("this._changedVariables")}this._changedVariables.add(variableName)}else{this.variableChangedEvent(variableName,value)}}}ResolveVariablePointer(varPointer){let contextIndex=varPointer.contextIndex;if(contextIndex==-1)contextIndex=this.GetContextIndexOfVariableNamed(varPointer.variableName);let valueOfVariablePointedTo=this.GetRawVariableWithName(varPointer.variableName,contextIndex);let doubleRedirectionPointer=asOrNull(valueOfVariablePointedTo,VariablePointerValue);if(doubleRedirectionPointer!=null){return doubleRedirectionPointer}else{return new VariablePointerValue(varPointer.variableName,contextIndex)}}GetContextIndexOfVariableNamed(varName){if(this._globalVariables.get(varName))return 0;return this._callStack.currentElementIndex}ObserveVariableChange(callback){this.variableChangedEventCallbacks.push(callback)}}class PRNG{constructor(seed){this.seed=seed%2147483647;if(this.seed<=0)this.seed+=2147483646}next(){return this.seed=this.seed*16807%2147483647}nextFloat(){return(this.next()-1)/2147483646}}class StoryState{constructor(story){this.kInkSaveStateVersion=8;this.kMinCompatibleLoadVersion=8;this._currentErrors=null;this._currentWarnings=null;this.divertedPointer=Pointer.Null;this._currentTurnIndex=0;this.storySeed=0;this.previousRandom=0;this.didSafeExit=false;this._currentText=null;this._currentTags=null;this._outputStreamTextDirty=true;this._outputStreamTagsDirty=true;this.story=story;this._outputStream=[];this.OutputStreamDirty();this._evaluationStack=[];this.callStack=new CallStack(story.rootContentContainer);this._variablesState=new VariablesState(this.callStack,story.listDefinitions);this._visitCounts=new Map;this._turnIndices=new Map;this._currentTurnIndex=-1;let timeSeed=(new Date).getTime();this.storySeed=new PRNG(timeSeed).next()%100;this.previousRandom=0;this._currentChoices=[];this.GoToStart()}ToJson(indented=false){return JSON.stringify(this.jsonToken,null,indented?2:0)}toJson(indented=false){return this.ToJson(indented)}LoadJson(json){this.jsonToken=JSON.parse(json)}VisitCountAtPathString(pathString){let visitCountOut=tryGetValueFromMap(this.visitCounts,pathString,null);if(visitCountOut.exists)return visitCountOut.result;return 0}get callstackDepth(){return this.callStack.depth}get outputStream(){return this._outputStream}get currentChoices(){if(this.canContinue)return[];return this._currentChoices}get generatedChoices(){return this._currentChoices}get currentErrors(){return this._currentErrors}get currentWarnings(){return this._currentWarnings}get variablesState(){return this._variablesState}get evaluationStack(){return this._evaluationStack}get visitCounts(){return this._visitCounts}get turnIndices(){return this._turnIndices}get currentTurnIndex(){return this._currentTurnIndex}get currentPathString(){let pointer=this.currentPointer;if(pointer.isNull){return null}else{if(pointer.path===null){return throwNullException("pointer.path")}return pointer.path.toString()}}get currentPointer(){return this.callStack.currentElement.currentPointer.copy()}set currentPointer(value){this.callStack.currentElement.currentPointer=value.copy()}get previousPointer(){return this.callStack.currentThread.previousPointer.copy()}set previousPointer(value){this.callStack.currentThread.previousPointer=value.copy()}get canContinue(){return!this.currentPointer.isNull&&!this.hasError}get hasError(){return this.currentErrors!=null&&this.currentErrors.length>0}get hasWarning(){return this.currentWarnings!=null&&this.currentWarnings.length>0}get currentText(){if(this._outputStreamTextDirty){let sb=new StringBuilder;for(let outputObj of this._outputStream){let textContent=asOrNull(outputObj,StringValue);if(textContent!==null){sb.Append(textContent.value)}}this._currentText=this.CleanOutputWhitespace(sb.toString());this._outputStreamTextDirty=false}return this._currentText}CleanOutputWhitespace(str){let sb=new StringBuilder;let currentWhitespaceStart=-1;let startOfLine=0;for(let i=0;i<str.length;i++){let c=str.charAt(i);let isInlineWhitespace=c==" "||c=="\t";if(isInlineWhitespace&&currentWhitespaceStart==-1)currentWhitespaceStart=i;if(!isInlineWhitespace){if(c!="\n"&&currentWhitespaceStart>0&&currentWhitespaceStart!=startOfLine){sb.Append(" ")}currentWhitespaceStart=-1}if(c=="\n")startOfLine=i+1;if(!isInlineWhitespace)sb.Append(c)}return sb.toString()}get currentTags(){if(this._outputStreamTagsDirty){this._currentTags=[];for(let outputObj of this._outputStream){let tag=asOrNull(outputObj,Tag);if(tag!==null){this._currentTags.push(tag.text)}}this._outputStreamTagsDirty=false}return this._currentTags}get inExpressionEvaluation(){return this.callStack.currentElement.inExpressionEvaluation}set inExpressionEvaluation(value){this.callStack.currentElement.inExpressionEvaluation=value}GoToStart(){this.callStack.currentElement.currentPointer=Pointer.StartOf(this.story.mainContentContainer)}Copy(){let copy=new StoryState(this.story);copy.outputStream.push.apply(copy.outputStream,this._outputStream);this.OutputStreamDirty();copy._currentChoices.push.apply(copy._currentChoices,this._currentChoices);if(this.hasError){copy._currentErrors=[];copy._currentErrors.push.apply(copy._currentErrors,this.currentErrors)}if(this.hasWarning){copy._currentWarnings=[];copy._currentWarnings.push.apply(copy._currentWarnings,this.currentWarnings)}copy.callStack=new CallStack(this.callStack);copy._variablesState=new VariablesState(copy.callStack,this.story.listDefinitions);copy.variablesState.CopyFrom(this.variablesState);copy.evaluationStack.push.apply(copy.evaluationStack,this.evaluationStack);if(!this.divertedPointer.isNull)copy.divertedPointer=this.divertedPointer.copy();copy.previousPointer=this.previousPointer.copy();copy._visitCounts=new Map(this.visitCounts);copy._turnIndices=new Map(this.turnIndices);copy._currentTurnIndex=this.currentTurnIndex;copy.storySeed=this.storySeed;copy.previousRandom=this.previousRandom;copy.didSafeExit=this.didSafeExit;return copy}get jsonToken(){let obj={};let choiceThreads;for(let c of this._currentChoices){if(c.threadAtGeneration===null){return throwNullException("c.threadAtGeneration")}c.originalThreadIndex=c.threadAtGeneration.threadIndex;if(this.callStack.ThreadWithIndex(c.originalThreadIndex)==null){if(choiceThreads==null)choiceThreads=new Map;choiceThreads[c.originalThreadIndex.toString()]=c.threadAtGeneration.jsonToken}}if(choiceThreads!=null)obj["choiceThreads"]=choiceThreads;obj["callstackThreads"]=this.callStack.GetJsonToken();obj["variablesState"]=this.variablesState.jsonToken;obj["evalStack"]=JsonSerialisation.ListToJArray(this.evaluationStack);obj["outputStream"]=JsonSerialisation.ListToJArray(this._outputStream);obj["currentChoices"]=JsonSerialisation.ListToJArray(this._currentChoices);if(!this.divertedPointer.isNull){if(this.divertedPointer.path===null){return throwNullException("this.divertedPointer.path")}obj["currentDivertTarget"]=this.divertedPointer.path.componentsString}obj["visitCounts"]=JsonSerialisation.IntDictionaryToJObject(this.visitCounts);obj["turnIndices"]=JsonSerialisation.IntDictionaryToJObject(this.turnIndices);obj["turnIdx"]=this.currentTurnIndex;obj["storySeed"]=this.storySeed;obj["inkSaveVersion"]=this.kInkSaveStateVersion;obj["inkFormatVersion"]=this.story.inkVersionCurrent;return obj}set jsonToken(value){let jObject=value;let jSaveVersion=jObject["inkSaveVersion"];if(jSaveVersion==null){throw new StoryException("ink save format incorrect, can't load.")}else if(parseInt(jSaveVersion)<this.kMinCompatibleLoadVersion){throw new StoryException("Ink save format isn't compatible with the current version (saw '"+jSaveVersion+"', but minimum is "+this.kMinCompatibleLoadVersion+"), so can't load.")}this.callStack.SetJsonToken(jObject["callstackThreads"],this.story);this.variablesState.jsonToken=jObject["variablesState"];this._evaluationStack=JsonSerialisation.JArrayToRuntimeObjList(jObject["evalStack"]);this._outputStream=JsonSerialisation.JArrayToRuntimeObjList(jObject["outputStream"]);this.OutputStreamDirty();this._currentChoices=JsonSerialisation.JArrayToRuntimeObjList(jObject["currentChoices"]);let currentDivertTargetPath=jObject["currentDivertTarget"];if(currentDivertTargetPath!=null){let divertPath=new Path(currentDivertTargetPath.toString());this.divertedPointer=this.story.PointerAtPath(divertPath)}this._visitCounts=JsonSerialisation.JObjectToIntDictionary(jObject["visitCounts"]);this._turnIndices=JsonSerialisation.JObjectToIntDictionary(jObject["turnIndices"]);this._currentTurnIndex=parseInt(jObject["turnIdx"]);this.storySeed=parseInt(jObject["storySeed"]);let jChoiceThreads=jObject["choiceThreads"];for(let c of this._currentChoices){let foundActiveThread=this.callStack.ThreadWithIndex(c.originalThreadIndex);if(foundActiveThread!=null){c.threadAtGeneration=foundActiveThread.Copy()}else{let jSavedChoiceThread=jChoiceThreads[c.originalThreadIndex.toString()];c.threadAtGeneration=new CallStack.Thread(jSavedChoiceThread,this.story)}}}ResetErrors(){this._currentErrors=null;this._currentWarnings=null}ResetOutput(objs=null){this._outputStream.length=0;if(objs!==null)this._outputStream.push.apply(this._outputStream,objs);this.OutputStreamDirty()}PushToOutputStream(obj){let text=asOrNull(obj,StringValue);if(text!==null){let listText=this.TrySplittingHeadTailWhitespace(text);if(listText!==null){for(let textObj of listText){this.PushToOutputStreamIndividual(textObj)}this.OutputStreamDirty();return}}this.PushToOutputStreamIndividual(obj);this.OutputStreamDirty()}PopFromOutputStream(count){this.outputStream.splice(this.outputStream.length-count,count);this.OutputStreamDirty()}TrySplittingHeadTailWhitespace(single){let str=single.value;if(str===null){return throwNullException("single.value")}let headFirstNewlineIdx=-1;let headLastNewlineIdx=-1;for(let i=0;i<str.length;++i){let c=str[i];if(c=="\n"){if(headFirstNewlineIdx==-1)headFirstNewlineIdx=i;headLastNewlineIdx=i}else if(c==" "||c=="\t")continue;else break}let tailLastNewlineIdx=-1;let tailFirstNewlineIdx=-1;for(let i=0;i<str.length;++i){let c=str[i];if(c=="\n"){if(tailLastNewlineIdx==-1)tailLastNewlineIdx=i;tailFirstNewlineIdx=i}else if(c==" "||c=="\t")continue;else break}if(headFirstNewlineIdx==-1&&tailLastNewlineIdx==-1)return null;let listTexts=[];let innerStrStart=0;let innerStrEnd=str.length;if(headFirstNewlineIdx!=-1){if(headFirstNewlineIdx>0){let leadingSpaces=new StringValue(str.substring(0,headFirstNewlineIdx));listTexts.push(leadingSpaces)}listTexts.push(new StringValue("\n"));innerStrStart=headLastNewlineIdx+1}if(tailLastNewlineIdx!=-1){innerStrEnd=tailFirstNewlineIdx}if(innerStrEnd>innerStrStart){let innerStrText=str.substring(innerStrStart,innerStrEnd-innerStrStart);listTexts.push(new StringValue(innerStrText))}if(tailLastNewlineIdx!=-1&&tailFirstNewlineIdx>headLastNewlineIdx){listTexts.push(new StringValue("\n"));if(tailLastNewlineIdx<str.length-1){let numSpaces=str.length-tailLastNewlineIdx-1;let trailingSpaces=new StringValue(str.substring(tailLastNewlineIdx+1,numSpaces));listTexts.push(trailingSpaces)}}return listTexts}PushToOutputStreamIndividual(obj){let glue=asOrNull(obj,Glue);let text=asOrNull(obj,StringValue);let includeInOutput=true;if(glue){this.TrimNewlinesFromOutputStream();includeInOutput=true}else if(text){let functionTrimIndex=-1;let currEl=this.callStack.currentElement;if(currEl.type==PushPopType.Function){functionTrimIndex=currEl.functionStartInOutputStream}let glueTrimIndex=-1;for(let i=this._outputStream.length-1;i>=0;i--){let o=this._outputStream[i];let c=o instanceof ControlCommand?o:null;let g=o instanceof Glue?o:null;if(g!=null){glueTrimIndex=i;break}else if(c!=null&&c.commandType==ControlCommand.CommandType.BeginString){if(i>=functionTrimIndex){functionTrimIndex=-1}break}}let trimIndex=-1;if(glueTrimIndex!=-1&&functionTrimIndex!=-1)trimIndex=Math.min(functionTrimIndex,glueTrimIndex);else if(glueTrimIndex!=-1)trimIndex=glueTrimIndex;else trimIndex=functionTrimIndex;if(trimIndex!=-1){if(text.isNewline){includeInOutput=false}else if(text.isNonWhitespace){if(glueTrimIndex>-1)this.RemoveExistingGlue();if(functionTrimIndex>-1){let callStackElements=this.callStack.elements;for(let i=callStackElements.length-1;i>=0;i--){let el=callStackElements[i];if(el.type==PushPopType.Function){el.functionStartInOutputStream=-1}else{break}}}}}else if(text.isNewline){if(this.outputStreamEndsInNewline||!this.outputStreamContainsContent)includeInOutput=false}}if(includeInOutput){if(obj===null){return throwNullException("obj")}this._outputStream.push(obj);this.OutputStreamDirty()}}TrimNewlinesFromOutputStream(){let removeWhitespaceFrom=-1;let i=this._outputStream.length-1;while(i>=0){let obj=this._outputStream[i];let cmd=asOrNull(obj,ControlCommand);let txt=asOrNull(obj,StringValue);if(cmd!=null||txt!=null&&txt.isNonWhitespace){break}else if(txt!=null&&txt.isNewline){removeWhitespaceFrom=i}i--}if(removeWhitespaceFrom>=0){i=removeWhitespaceFrom;while(i<this._outputStream.length){let text=asOrNull(this._outputStream[i],StringValue);if(text){this._outputStream.splice(i,1)}else{i++}}}this.OutputStreamDirty()}RemoveExistingGlue(){for(let i=this._outputStream.length-1;i>=0;i--){let c=this._outputStream[i];if(c instanceof Glue){this._outputStream.splice(i,1)}else if(c instanceof ControlCommand){break}}this.OutputStreamDirty()}get outputStreamEndsInNewline(){if(this._outputStream.length>0){for(let i=this._outputStream.length-1;i>=0;i--){let obj=this._outputStream[i];if(obj instanceof ControlCommand)break;let text=this._outputStream[i];if(text instanceof StringValue){if(text.isNewline)return true;else if(text.isNonWhitespace)break}}}return false}get outputStreamContainsContent(){for(let i=0;i<this._outputStream.length;i++){if(this._outputStream[i]instanceof StringValue)return true}return false}get inStringEvaluation(){for(let i=this._outputStream.length-1;i>=0;i--){let cmd=asOrNull(this._outputStream[i],ControlCommand);if(cmd instanceof ControlCommand&&cmd.commandType==ControlCommand.CommandType.BeginString){return true}}return false}PushEvaluationStack(obj){let listValue=asOrNull(obj,ListValue);if(listValue){let rawList=listValue.value;if(rawList===null){return throwNullException("rawList")}if(rawList.originNames!=null){if(!rawList.origins)rawList.origins=[];rawList.origins.length=0;for(let n of rawList.originNames){if(this.story.listDefinitions===null)return throwNullException("StoryState.story.listDefinitions");let def=this.story.listDefinitions.TryListGetDefinition(n,null);if(def.result===null)return throwNullException("StoryState def.result");if(rawList.origins.indexOf(def.result)<0)rawList.origins.push(def.result)}}}if(obj===null){return throwNullException("obj")}this.evaluationStack.push(obj)}PopEvaluationStack(numberOfObjects){if(typeof numberOfObjects==="undefined"){let obj=this.evaluationStack.pop();return nullIfUndefined(obj)}else{if(numberOfObjects>this.evaluationStack.length){throw new Error("trying to pop too many objects")}let popped=this.evaluationStack.splice(this.evaluationStack.length-numberOfObjects,numberOfObjects);return nullIfUndefined(popped)}}PeekEvaluationStack(){return this.evaluationStack[this.evaluationStack.length-1]}ForceEnd(){while(this.callStack.canPopThread)this.callStack.PopThread();while(this.callStack.canPop)this.PopCallStack();this._currentChoices.length=0;this.currentPointer=Pointer.Null;this.previousPointer=Pointer.Null;this.didSafeExit=true}TrimWhitespaceFromFunctionEnd(){Debug.Assert(this.callStack.currentElement.type==PushPopType.Function);let functionStartPoint=this.callStack.currentElement.functionStartInOutputStream;if(functionStartPoint==-1){functionStartPoint=0}for(let i=this._outputStream.length-1;i>=functionStartPoint;i--){let obj=this._outputStream[i];let txt=asOrNull(obj,StringValue);let cmd=asOrNull(obj,ControlCommand);if(txt==null)continue;if(cmd)break;if(txt.isNewline||txt.isInlineWhitespace){this._outputStream.splice(i,1);this.OutputStreamDirty()}else{break}}}PopCallStack(popType=null){if(this.callStack.currentElement.type==PushPopType.Function)this.TrimWhitespaceFromFunctionEnd();this.callStack.Pop(popType)}SetChosenPath(path,incrementingTurnIndex){this._currentChoices.length=0;let newPointer=this.story.PointerAtPath(path);if(!newPointer.isNull&&newPointer.index==-1)newPointer.index=0;this.currentPointer=newPointer;if(incrementingTurnIndex)this._currentTurnIndex++}StartFunctionEvaluationFromGame(funcContainer,args){this.callStack.Push(PushPopType.FunctionEvaluationFromGame,this.evaluationStack.length);this.callStack.currentElement.currentPointer=Pointer.StartOf(funcContainer);this.PassArgumentsToEvaluationStack(args)}PassArgumentsToEvaluationStack(args){if(args!=null){for(let i=0;i<args.length;i++){if(!(typeof args[i]==="number"||typeof args[i]==="string")){throw new Error("ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string")}this.PushEvaluationStack(Value.Create(args[i]))}}}TryExitFunctionEvaluationFromGame(){if(this.callStack.currentElement.type==PushPopType.FunctionEvaluationFromGame){this.currentPointer=Pointer.Null;this.didSafeExit=true;return true}return false}CompleteFunctionEvaluationFromGame(){if(this.callStack.currentElement.type!=PushPopType.FunctionEvaluationFromGame){throw new StoryException("Expected external function evaluation to be complete. Stack trace: "+this.callStack.callStackTrace)}let originalEvaluationStackHeight=this.callStack.currentElement.evaluationStackHeightWhenPushed;let returnedObj=null;while(this.evaluationStack.length>originalEvaluationStackHeight){let poppedObj=this.PopEvaluationStack();if(returnedObj===null)returnedObj=poppedObj}this.PopCallStack(PushPopType.FunctionEvaluationFromGame);if(returnedObj){if(returnedObj instanceof Void)return null;let returnVal=asOrThrows(returnedObj,Value);if(returnVal.valueType==ValueType.DivertTarget){return returnVal.valueObject.toString()}return returnVal.valueObject}return null}AddError(message,isWarning){if(!isWarning){if(this._currentErrors==null)this._currentErrors=[];this._currentErrors.push(message)}else{if(this._currentWarnings==null)this._currentWarnings=[];this._currentWarnings.push(message)}}OutputStreamDirty(){this._outputStreamTextDirty=true;this._outputStreamTagsDirty=true}}class Stopwatch{constructor(){this.startTime=undefined}get ElapsedMilliseconds(){if(typeof this.startTime==="undefined"){return 0}return(new Date).getTime()-this.startTime}Start(){this.startTime=(new Date).getTime()}Stop(){this.startTime=undefined}}if(!Number.isInteger){Number.isInteger=function isInteger(nVal){return typeof nVal==="number"&&isFinite(nVal)&&nVal>-9007199254740992&&nVal<9007199254740992&&Math.floor(nVal)===nVal}}class Story extends InkObject{constructor(){super();this.inkVersionCurrent=19;this.inkVersionMinimumCompatible=18;this._prevContainers=[];this.allowExternalFunctionFallbacks=false;this._listDefinitions=null;this._variableObservers=null;this._hasValidatedExternals=false;this._temporaryEvaluationContainer=null;this._asyncContinueActive=false;this._stateAtLastNewline=null;this._recursiveContinueCount=0;this._profiler=null;let contentContainer;let lists=null;let json=null;if(arguments[0]instanceof Container){contentContainer=arguments[0];if(typeof arguments[1]!=="undefined"){lists=arguments[1]}this._mainContentContainer=contentContainer}else{if(typeof arguments[0]==="string"){let jsonString=arguments[0];json=JSON.parse(jsonString)}else{json=arguments[0]}}if(lists!=null)this._listDefinitions=new ListDefinitionsOrigin(lists);this._externals=new Map;if(json!==null){let rootObject=json;let versionObj=rootObject["inkVersion"];if(versionObj==null)throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");let formatFromFile=parseInt(versionObj);if(formatFromFile>this.inkVersionCurrent){throw new Error("Version of ink used to build story was newer than the current version of the engine")}else if(formatFromFile<this.inkVersionMinimumCompatible){throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine")}else if(formatFromFile!=this.inkVersionCurrent){console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.")}let rootToken=rootObject["root"];if(rootToken==null)throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");let listDefsObj;if(listDefsObj=rootObject["listDefs"]){this._listDefinitions=JsonSerialisation.JTokenToListDefinitions(listDefsObj)}this._mainContentContainer=asOrThrows(JsonSerialisation.JTokenToRuntimeObject(rootToken),Container);this.ResetState()}}get currentChoices(){let choices=[];if(this._state===null){return throwNullException("this._state")}for(let c of this._state.currentChoices){if(!c.isInvisibleDefault){c.index=choices.length;choices.push(c)}}return choices}get currentText(){this.IfAsyncWeCant("call currentText since it's a work in progress");return this.state.currentText}get currentTags(){this.IfAsyncWeCant("call currentTags since it's a work in progress");return this.state.currentTags}get currentErrors(){return this.state.currentErrors}get currentWarnings(){return this.state.currentWarnings}get hasError(){return this.state.hasError}get hasWarning(){return this.state.hasWarning}get variablesState(){return this.state.variablesState}get listDefinitions(){return this._listDefinitions}get state(){return this._state}StartProfiling(){}EndProfiling(){}ToJsonString(){let rootContainerJsonList=JsonSerialisation.RuntimeObjectToJToken(this._mainContentContainer);let rootObject={};rootObject["inkVersion"]=this.inkVersionCurrent;rootObject["root"]=rootContainerJsonList;if(this._listDefinitions!=null)rootObject["listDefs"]=JsonSerialisation.ListDefinitionsToJToken(this._listDefinitions);return JSON.stringify(rootObject)}ResetState(){this.IfAsyncWeCant("ResetState");this._state=new StoryState(this);this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this));this.ResetGlobals()}ResetErrors(){if(this._state===null){return throwNullException("this._state")}this._state.ResetErrors()}ResetCallstack(){this.IfAsyncWeCant("ResetCallstack");if(this._state===null){return throwNullException("this._state")}this._state.ForceEnd()}ResetGlobals(){if(this._mainContentContainer.namedContent.get("global decl")){let originalPointer=this.state.currentPointer.copy();this.ChoosePath(new Path("global decl"),false);this.ContinueInternal();this.state.currentPointer=originalPointer}this.state.variablesState.SnapshotDefaultGlobals()}Continue(){this.ContinueAsync(0);return this.currentText}get canContinue(){return this.state.canContinue}get asyncContinueComplete(){return!this._asyncContinueActive}ContinueAsync(millisecsLimitAsync){if(!this._hasValidatedExternals)this.ValidateExternalBindings();this.ContinueInternal(millisecsLimitAsync)}ContinueInternal(millisecsLimitAsync=0){if(this._profiler!=null)this._profiler.PreContinue();let isAsyncTimeLimited=millisecsLimitAsync>0;this._recursiveContinueCount++;if(!this._asyncContinueActive){this._asyncContinueActive=isAsyncTimeLimited;if(!this.canContinue){throw new StoryException("Can't continue - should check canContinue before calling Continue")}this._state.didSafeExit=false;this._state.ResetOutput();if(this._recursiveContinueCount==1)this._state.variablesState.batchObservingVariableChanges=true}let durationStopwatch=new Stopwatch;durationStopwatch.Start();let outputStreamEndsInNewline=false;do{try{outputStreamEndsInNewline=this.ContinueSingleStep()}catch(e){if(!(e instanceof StoryException))throw e;this.AddError(e.message,undefined,e.useEndLineNumber);break}if(outputStreamEndsInNewline)break;if(this._asyncContinueActive&&durationStopwatch.ElapsedMilliseconds>millisecsLimitAsync){break}}while(this.canContinue);durationStopwatch.Stop();if(outputStreamEndsInNewline||!this.canContinue){if(this._stateAtLastNewline!=null){this.RestoreStateSnapshot(this._stateAtLastNewline);this._stateAtLastNewline=null}if(!this.canContinue){if(this.state.callStack.canPopThread)this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?");if(this.state.generatedChoices.length==0&&!this.state.didSafeExit&&this._temporaryEvaluationContainer==null){if(this.state.callStack.CanPop(PushPopType.Tunnel))this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?");else if(this.state.callStack.CanPop(PushPopType.Function))this.AddError("unexpectedly reached end of content. Do you need a '~ return'?");else if(!this.state.callStack.canPop)this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?");else this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!")}}this.state.didSafeExit=false;if(this._recursiveContinueCount==1)this._state.variablesState.batchObservingVariableChanges=false;this._asyncContinueActive=false}this._recursiveContinueCount--;if(this._profiler!=null)this._profiler.PostContinue()}ContinueSingleStep(){if(this._profiler!=null)this._profiler.PreStep();this.Step();if(this._profiler!=null)this._profiler.PostStep();if(!this.canContinue&&!this.state.callStack.elementIsEvaluateFromGame){this.TryFollowDefaultInvisibleChoice()}if(this._profiler!=null)this._profiler.PreSnapshot();if(!this.state.inStringEvaluation){if(this._stateAtLastNewline!=null){if(this._stateAtLastNewline.currentTags===null){return throwNullException("this._stateAtLastNewline.currentTags")}if(this.state.currentTags===null){return throwNullException("this.state.currentTags")}let change=this.CalculateNewlineOutputStateChange(this._stateAtLastNewline.currentText,this.state.currentText,this._stateAtLastNewline.currentTags.length,this.state.currentTags.length);if(change==Story.OutputStateChange.ExtendedBeyondNewline){this.RestoreStateSnapshot(this._stateAtLastNewline);return true}else if(change==Story.OutputStateChange.NewlineRemoved){this._stateAtLastNewline=null}}if(this.state.outputStreamEndsInNewline){if(this.canContinue){if(this._stateAtLastNewline==null)this._stateAtLastNewline=this.StateSnapshot()}else{this._stateAtLastNewline=null}}}if(this._profiler!=null)this._profiler.PostSnapshot();return false}CalculateNewlineOutputStateChange(prevText,currText,prevTagCount,currTagCount){if(prevText===null){return throwNullException("prevText")}if(currText===null){return throwNullException("currText")}let newlineStillExists=currText.length>=prevText.length&&currText.charAt(prevText.length-1)=="\n";if(prevTagCount==currTagCount&&prevText.length==currText.length&&newlineStillExists)return Story.OutputStateChange.NoChange;if(!newlineStillExists){return Story.OutputStateChange.NewlineRemoved}if(currTagCount>prevTagCount)return Story.OutputStateChange.ExtendedBeyondNewline;for(let i=prevText.length;i<currText.length;i++){let c=currText.charAt(i);if(c!=" "&&c!="\t"){return Story.OutputStateChange.ExtendedBeyondNewline}}return Story.OutputStateChange.NoChange}ContinueMaximally(){this.IfAsyncWeCant("ContinueMaximally");let sb=new StringBuilder;while(this.canContinue){sb.Append(this.Continue())}return sb.toString()}ContentAtPath(path){return this.mainContentContainer.ContentAtPath(path)}KnotContainerWithName(name){let namedContainer=this.mainContentContainer.namedContent.get(name);if(namedContainer instanceof Container)return namedContainer;else return null}PointerAtPath(path){if(path.length==0)return Pointer.Null;let p=new Pointer;let pathLengthToUse=path.length;let result=null;if(path.lastComponent===null){return throwNullException("path.lastComponent")}if(path.lastComponent.isIndex){pathLengthToUse=path.length-1;result=this.mainContentContainer.ContentAtPath(path,undefined,pathLengthToUse);p.container=result.container;p.index=path.lastComponent.index}else{result=this.mainContentContainer.ContentAtPath(path);p.container=result.container;p.index=-1}if(result.obj==null||result.obj==this.mainContentContainer&&pathLengthToUse>0){this.Error("Failed to find content at path '"+path+"', and no approximation of it was possible.")}else if(result.approximate)this.Warning("Failed to find content at path '"+path+"', so it was approximated to: '"+result.obj.path+"'.");return p}StateSnapshot(){return this.state.Copy()}RestoreStateSnapshot(state){this._state=state}Step(){let shouldAddToStream=true;let pointer=this.state.currentPointer.copy();if(pointer.isNull){return}let containerToEnter=asOrNull(pointer.Resolve(),Container);while(containerToEnter){this.VisitContainer(containerToEnter,true);if(containerToEnter.content.length==0){break}pointer=Pointer.StartOf(containerToEnter);containerToEnter=asOrNull(pointer.Resolve(),Container)}this.state.currentPointer=pointer.copy();if(this._profiler!=null)this._profiler.Step(this.state.callStack);let currentContentObj=pointer.Resolve();let isLogicOrFlowControl=this.PerformLogicAndFlowControl(currentContentObj);if(this.state.currentPointer.isNull){return}if(isLogicOrFlowControl){shouldAddToStream=false}let choicePoint=asOrNull(currentContentObj,ChoicePoint);if(choicePoint){let choice=this.ProcessChoice(choicePoint);if(choice){this.state.generatedChoices.push(choice)}currentContentObj=null;shouldAddToStream=false}if(currentContentObj instanceof Container){shouldAddToStream=false}if(shouldAddToStream){let varPointer=asOrNull(currentContentObj,VariablePointerValue);if(varPointer&&varPointer.contextIndex==-1){let contextIdx=this.state.callStack.ContextForVariableNamed(varPointer.variableName);currentContentObj=new VariablePointerValue(varPointer.variableName,contextIdx)}if(this.state.inExpressionEvaluation){this.state.PushEvaluationStack(currentContentObj)}else{this.state.PushToOutputStream(currentContentObj)}}this.NextContent();let controlCmd=asOrNull(currentContentObj,ControlCommand);if(controlCmd&&controlCmd.commandType==ControlCommand.CommandType.StartThread){this.state.callStack.PushThread()}}VisitContainer(container,atStart){if(!container.countingAtStartOnly||atStart){if(container.visitsShouldBeCounted)this.IncrementVisitCountForContainer(container);if(container.turnIndexShouldBeCounted)this.RecordTurnIndexVisitToContainer(container)}}VisitChangedContainersDueToDivert(){let previousPointer=this.state.previousPointer.copy();let pointer=this.state.currentPointer.copy();if(pointer.isNull||pointer.index==-1)return;this._prevContainers.length=0;if(!previousPointer.isNull){let resolvedPreviousAncestor=previousPointer.Resolve();let prevAncestor=asOrNull(resolvedPreviousAncestor,Container)||asOrNull(previousPointer.container,Container);while(prevAncestor){this._prevContainers.push(prevAncestor);prevAncestor=asOrNull(prevAncestor.parent,Container)}}let currentChildOfContainer=pointer.Resolve();if(currentChildOfContainer==null)return;let currentContainerAncestor=asOrNull(currentChildOfContainer.parent,Container);while(currentContainerAncestor&&(this._prevContainers.indexOf(currentContainerAncestor)<0||currentContainerAncestor.countingAtStartOnly)){let enteringAtStart=currentContainerAncestor.content.length>0&&currentChildOfContainer==currentContainerAncestor.content[0];this.VisitContainer(currentContainerAncestor,enteringAtStart);currentChildOfContainer=currentContainerAncestor;currentContainerAncestor=asOrNull(currentContainerAncestor.parent,Container)}}ProcessChoice(choicePoint){let showChoice=true;if(choicePoint.hasCondition){let conditionValue=this.state.PopEvaluationStack();if(!this.IsTruthy(conditionValue)){showChoice=false}}let startText="";let choiceOnlyText="";if(choicePoint.hasChoiceOnlyContent){let choiceOnlyStrVal=asOrThrows(this.state.PopEvaluationStack(),StringValue);choiceOnlyText=choiceOnlyStrVal.value||""}if(choicePoint.hasStartContent){let startStrVal=asOrThrows(this.state.PopEvaluationStack(),StringValue);startText=startStrVal.value||""}if(choicePoint.onceOnly){let visitCount=this.VisitCountForContainer(choicePoint.choiceTarget);if(visitCount>0){showChoice=false}}if(!showChoice){return null}let choice=new Choice;choice.targetPath=choicePoint.pathOnChoice;choice.sourcePath=choicePoint.path.toString();choice.isInvisibleDefault=choicePoint.isInvisibleDefault;choice.threadAtGeneration=this.state.callStack.currentThread.Copy();choice.text=(startText+choiceOnlyText).replace(/^[ \t]+|[ \t]+$/g,"");return choice}IsTruthy(obj){let truthy=false;if(obj instanceof Value){let val=obj;if(val instanceof DivertTargetValue){let divTarget=val;this.Error("Shouldn't use a divert target (to "+divTarget.targetPath+") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)");return false}return val.isTruthy}return truthy}PerformLogicAndFlowControl(contentObj){if(contentObj==null){return false}if(contentObj instanceof Divert){let currentDivert=contentObj;if(currentDivert.isConditional){let conditionValue=this.state.PopEvaluationStack();if(!this.IsTruthy(conditionValue))return true}if(currentDivert.hasVariableTarget){let varName=currentDivert.variableDivertName;let varContents=this.state.variablesState.GetVariableWithName(varName);if(varContents==null){this.Error("Tried to divert using a target from a variable that could not be found ("+varName+")")}else if(!(varContents instanceof DivertTargetValue)){let intContent=asOrNull(varContents,IntValue);let errorMessage="Tried to divert to a target from a variable, but the variable ("+varName+") didn't contain a divert target, it ";if(intContent instanceof IntValue&&intContent.value==0){errorMessage+="was empty/null (the value 0)."}else{errorMessage+="contained '"+varContents+"'."}this.Error(errorMessage)}let target=asOrThrows(varContents,DivertTargetValue);this.state.divertedPointer=this.PointerAtPath(target.targetPath)}else if(currentDivert.isExternal){this.CallExternalFunction(currentDivert.targetPathString,currentDivert.externalArgs);return true}else{this.state.divertedPointer=currentDivert.targetPointer.copy()}if(currentDivert.pushesToStack){this.state.callStack.Push(currentDivert.stackPushType,undefined,this.state.outputStream.length)}if(this.state.divertedPointer.isNull&&!currentDivert.isExternal){if(currentDivert&&currentDivert.debugMetadata&&currentDivert.debugMetadata.sourceName!=null){this.Error("Divert target doesn't exist: "+currentDivert.debugMetadata.sourceName)}else{this.Error("Divert resolution failed: "+currentDivert)}}return true}else if(contentObj instanceof ControlCommand){let evalCommand=contentObj;switch(evalCommand.commandType){case ControlCommand.CommandType.EvalStart:this.Assert(this.state.inExpressionEvaluation===false,"Already in expression evaluation?");this.state.inExpressionEvaluation=true;break;case ControlCommand.CommandType.EvalEnd:this.Assert(this.state.inExpressionEvaluation===true,"Not in expression evaluation mode");this.state.inExpressionEvaluation=false;break;case ControlCommand.CommandType.EvalOutput:if(this.state.evaluationStack.length>0){let output=this.state.PopEvaluationStack();if(!(output instanceof Void)){let text=new StringValue(output.toString());this.state.PushToOutputStream(text)}}break;case ControlCommand.CommandType.NoOp:break;case ControlCommand.CommandType.Duplicate:this.state.PushEvaluationStack(this.state.PeekEvaluationStack());break;case ControlCommand.CommandType.PopEvaluatedValue:this.state.PopEvaluationStack();break;case ControlCommand.CommandType.PopFunction:case ControlCommand.CommandType.PopTunnel:let popType=evalCommand.commandType==ControlCommand.CommandType.PopFunction?PushPopType.Function:PushPopType.Tunnel;let overrideTunnelReturnTarget=null;if(popType==PushPopType.Tunnel){let popped=this.state.PopEvaluationStack();overrideTunnelReturnTarget=asOrNull(popped,DivertTargetValue);if(overrideTunnelReturnTarget===null){this.Assert(popped instanceof Void,"Expected void if ->-> doesn't override target")}}if(this.state.TryExitFunctionEvaluationFromGame()){break}else if(this.state.callStack.currentElement.type!=popType||!this.state.callStack.canPop){let names=new Map;names.set(PushPopType.Function,"function return statement (~ return)");names.set(PushPopType.Tunnel,"tunnel onwards statement (->->)");let expected=names.get(this.state.callStack.currentElement.type);if(!this.state.callStack.canPop){expected="end of flow (-> END or choice)"}let errorMsg="Found "+names.get(popType)+", when expected "+expected;this.Error(errorMsg)}else{this.state.PopCallStack();if(overrideTunnelReturnTarget)this.state.divertedPointer=this.PointerAtPath(overrideTunnelReturnTarget.targetPath)}break;case ControlCommand.CommandType.BeginString:this.state.PushToOutputStream(evalCommand);this.Assert(this.state.inExpressionEvaluation===true,"Expected to be in an expression when evaluating a string");this.state.inExpressionEvaluation=false;break;case ControlCommand.CommandType.EndString:let contentStackForString=[];let outputCountConsumed=0;for(let i=this.state.outputStream.length-1;i>=0;--i){let obj=this.state.outputStream[i];outputCountConsumed++;let command=asOrNull(obj,ControlCommand);if(command&&command.commandType==ControlCommand.CommandType.BeginString){break}if(obj instanceof StringValue){contentStackForString.push(obj)}}this.state.PopFromOutputStream(outputCountConsumed);contentStackForString=contentStackForString.reverse();let sb=new StringBuilder;for(let c of contentStackForString){sb.Append(c.toString())}this.state.inExpressionEvaluation=true;this.state.PushEvaluationStack(new StringValue(sb.toString()));break;case ControlCommand.CommandType.ChoiceCount:let choiceCount=this.state.generatedChoices.length;this.state.PushEvaluationStack(new IntValue(choiceCount));break;case ControlCommand.CommandType.Turns:this.state.PushEvaluationStack(new IntValue(this.state.currentTurnIndex+1));break;case ControlCommand.CommandType.TurnsSince:case ControlCommand.CommandType.ReadCount:let target=this.state.PopEvaluationStack();if(!(target instanceof DivertTargetValue)){let extraNote="";if(target instanceof IntValue)extraNote=". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?";this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw "+target+extraNote);break}let divertTarget=asOrThrows(target,DivertTargetValue);let container=asOrNull(this.ContentAtPath(divertTarget.targetPath).correctObj,Container);let eitherCount;if(container!=null){if(evalCommand.commandType==ControlCommand.CommandType.TurnsSince)eitherCount=this.TurnsSinceForContainer(container);else eitherCount=this.VisitCountForContainer(container)}else{if(evalCommand.commandType==ControlCommand.CommandType.TurnsSince)eitherCount=-1;else eitherCount=0;this.Warning("Failed to find container for "+evalCommand.toString()+" lookup at "+divertTarget.targetPath.toString())}this.state.PushEvaluationStack(new IntValue(eitherCount));break;case ControlCommand.CommandType.Random:{let maxInt=asOrNull(this.state.PopEvaluationStack(),IntValue);let minInt=asOrNull(this.state.PopEvaluationStack(),IntValue);if(minInt==null||minInt instanceof IntValue===false)return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");if(maxInt==null||minInt instanceof IntValue===false)return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");if(maxInt.value===null){return throwNullException("maxInt.value")}if(minInt.value===null){return throwNullException("minInt.value")}let randomRange=maxInt.value-minInt.value+1;if(randomRange<=0)this.Error("RANDOM was called with minimum as "+minInt.value+" and maximum as "+maxInt.value+". The maximum must be larger");let resultSeed=this.state.storySeed+this.state.previousRandom;let random=new PRNG(resultSeed);let nextRandom=random.next();let chosenValue=nextRandom%randomRange+minInt.value;this.state.PushEvaluationStack(new IntValue(chosenValue));this.state.previousRandom=nextRandom;break}case ControlCommand.CommandType.SeedRandom:let seed=asOrNull(this.state.PopEvaluationStack(),IntValue);if(seed==null||seed instanceof IntValue===false)return this.Error("Invalid value passed to SEED_RANDOM");if(seed.value===null){return throwNullException("minInt.value")}this.state.storySeed=seed.value;this.state.previousRandom=0;this.state.PushEvaluationStack(new Void);break;case ControlCommand.CommandType.VisitIndex:let count=this.VisitCountForContainer(this.state.currentPointer.container)-1;this.state.PushEvaluationStack(new IntValue(count));break;case ControlCommand.CommandType.SequenceShuffleIndex:let shuffleIndex=this.NextSequenceShuffleIndex();this.state.PushEvaluationStack(new IntValue(shuffleIndex));break;case ControlCommand.CommandType.StartThread:break;case ControlCommand.CommandType.Done:if(this.state.callStack.canPopThread){this.state.callStack.PopThread()}else{this.state.didSafeExit=true;this.state.currentPointer=Pointer.Null}break;case ControlCommand.CommandType.End:this.state.ForceEnd();break;case ControlCommand.CommandType.ListFromInt:let intVal=asOrNull(this.state.PopEvaluationStack(),IntValue);let listNameVal=asOrThrows(this.state.PopEvaluationStack(),StringValue);if(intVal===null){throw new StoryException("Passed non-integer when creating a list element from a numerical value.")}let generatedListValue=null;if(this.listDefinitions===null){return throwNullException("this.listDefinitions")}let foundListDef=this.listDefinitions.TryListGetDefinition(listNameVal.value,null);if(foundListDef.exists){if(intVal.value===null){return throwNullException("minInt.value")}let foundItem=foundListDef.result.TryGetItemWithValue(intVal.value,InkListItem.Null);if(foundItem.exists){generatedListValue=new ListValue(foundItem.result,intVal.value)}}else{throw new StoryException("Failed to find LIST called "+listNameVal.value)}if(generatedListValue==null)generatedListValue=new ListValue;this.state.PushEvaluationStack(generatedListValue);break;case ControlCommand.CommandType.ListRange:let max=asOrNull(this.state.PopEvaluationStack(),Value);let min=asOrNull(this.state.PopEvaluationStack(),Value);let targetList=asOrNull(this.state.PopEvaluationStack(),ListValue);if(targetList===null||min===null||max===null)throw new StoryException("Expected list, minimum and maximum for LIST_RANGE");if(targetList.value===null){return throwNullException("targetList.value")}let result=targetList.value.ListWithSubRange(min.valueObject,max.valueObject);this.state.PushEvaluationStack(new ListValue(result));break;case ControlCommand.CommandType.ListRandom:{let listVal=this.state.PopEvaluationStack();if(listVal===null)throw new StoryException("Expected list for LIST_RANDOM");let list=listVal.value;let newList=null;if(list===null){throw throwNullException("list")}if(list.Count==0){newList=new InkList}else{let resultSeed=this.state.storySeed+this.state.previousRandom;let random=new PRNG(resultSeed);let nextRandom=random.next();let listItemIndex=nextRandom%list.Count;let listEnumerator=list.entries();for(let i=0;i<=listItemIndex-1;i++){listEnumerator.next()}let value=listEnumerator.next().value;let randomItem={Key:InkListItem.fromSerializedKey(value[0]),Value:value[1]};if(randomItem.Key.originName===null){return throwNullException("randomItem.Key.originName")}newList=new InkList(randomItem.Key.originName,this);newList.Add(randomItem.Key,randomItem.Value);this.state.previousRandom=nextRandom}this.state.PushEvaluationStack(new ListValue(newList));break}default:this.Error("unhandled ControlCommand: "+evalCommand);break}return true}else if(contentObj instanceof VariableAssignment){let varAss=contentObj;let assignedVal=this.state.PopEvaluationStack();this.state.variablesState.Assign(varAss,assignedVal);return true}else if(contentObj instanceof VariableReference){let varRef=contentObj;let foundValue=null;if(varRef.pathForCount!=null){let container=varRef.containerForCount;let count=this.VisitCountForContainer(container);foundValue=new IntValue(count)}else{foundValue=this.state.variablesState.GetVariableWithName(varRef.name);if(foundValue==null){let defaultVal=this.state.variablesState.TryGetDefaultVariableValue(varRef.name);if(defaultVal!=null){this.Warning("Variable not found in save state: '"+varRef.name+"', but seems to have been newly created. Assigning value from latest ink's declaration: "+defaultVal);foundValue=defaultVal;this.state.variablesState.SetGlobal(varRef.name,foundValue)}else{this.Warning("Variable not found: '"+varRef.name+"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit.");foundValue=new IntValue(0)}}}this.state.PushEvaluationStack(foundValue);return true}else if(contentObj instanceof NativeFunctionCall){let func=contentObj;let funcParams=this.state.PopEvaluationStack(func.numberOfParameters);let result=func.Call(funcParams);this.state.PushEvaluationStack(result);return true}return false}ChoosePathString(path,resetCallstack=true,args=[]){this.IfAsyncWeCant("call ChoosePathString right now");if(resetCallstack){this.ResetCallstack()}else{if(this.state.callStack.currentElement.type==PushPopType.Function){let funcDetail="";let container=this.state.callStack.currentElement.currentPointer.container;if(container!=null){funcDetail="("+container.path.toString()+") "}throw new Error("Story was running a function "+funcDetail+"when you called ChoosePathString("+path+") - this is almost certainly not not what you want! Full stack trace: \n"+this.state.callStack.callStackTrace)}}this.state.PassArgumentsToEvaluationStack(args);this.ChoosePath(new Path(path))}IfAsyncWeCant(activityStr){if(this._asyncContinueActive)throw new Error("Can't "+activityStr+". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.")}ChoosePath(p,incrementingTurnIndex=true){this.state.SetChosenPath(p,incrementingTurnIndex);this.VisitChangedContainersDueToDivert()}ChooseChoiceIndex(choiceIdx){choiceIdx=choiceIdx;let choices=this.currentChoices;this.Assert(choiceIdx>=0&&choiceIdx<choices.length,"choice out of range");let choiceToChoose=choices[choiceIdx];if(choiceToChoose.threadAtGeneration===null){return throwNullException("choiceToChoose.threadAtGeneration")}if(choiceToChoose.targetPath===null){return throwNullException("choiceToChoose.targetPath")}this.state.callStack.currentThread=choiceToChoose.threadAtGeneration;this.ChoosePath(choiceToChoose.targetPath)}HasFunction(functionName){try{return this.KnotContainerWithName(functionName)!=null}catch(e){return false}}EvaluateFunction(functionName,args=[],returnTextOutput=false){this.IfAsyncWeCant("evaluate a function");if(functionName==null){throw new Error("Function is null")}else if(functionName==""||functionName.trim()==""){throw new Error("Function is empty or white space.")}let funcContainer=this.KnotContainerWithName(functionName);if(funcContainer==null){throw new Error("Function doesn't exist: '"+functionName+"'")}let outputStreamBefore=[];outputStreamBefore.push.apply(outputStreamBefore,this.state.outputStream);this._state.ResetOutput();this.state.StartFunctionEvaluationFromGame(funcContainer,args);let stringOutput=new StringBuilder;while(this.canContinue){stringOutput.Append(this.Continue())}let textOutput=stringOutput.toString();this._state.ResetOutput(outputStreamBefore);let result=this.state.CompleteFunctionEvaluationFromGame();return returnTextOutput?{returned:result,output:textOutput}:result}EvaluateExpression(exprContainer){let startCallStackHeight=this.state.callStack.elements.length;this.state.callStack.Push(PushPopType.Tunnel);this._temporaryEvaluationContainer=exprContainer;this.state.GoToStart();let evalStackHeight=this.state.evaluationStack.length;this.Continue();this._temporaryEvaluationContainer=null;if(this.state.callStack.elements.length>startCallStackHeight){this.state.PopCallStack()}let endStackHeight=this.state.evaluationStack.length;if(endStackHeight>evalStackHeight){return this.state.PopEvaluationStack()}else{return null}}CallExternalFunction(funcName,numberOfArguments){if(funcName===null){return throwNullException("funcName")}let func=this._externals.get(funcName);let fallbackFunctionContainer=null;let foundExternal=typeof func!=="undefined";if(!foundExternal){if(this.allowExternalFunctionFallbacks){fallbackFunctionContainer=this.KnotContainerWithName(funcName);this.Assert(fallbackFunctionContainer!==null,"Trying to call EXTERNAL function '"+funcName+"' which has not been bound, and fallback ink function could not be found.");this.state.callStack.Push(PushPopType.Function,undefined,this.state.outputStream.length);this.state.divertedPointer=Pointer.StartOf(fallbackFunctionContainer);return}else{this.Assert(false,"Trying to call EXTERNAL function '"+funcName+"' which has not been bound (and ink fallbacks disabled).")}}let args=[];for(let i=0;i<numberOfArguments;++i){let poppedObj=asOrThrows(this.state.PopEvaluationStack(),Value);let valueObj=poppedObj.valueObject;args.push(valueObj)}args.reverse();let funcResult=func(args);let returnObj=null;if(funcResult!=null){returnObj=Value.Create(funcResult);this.Assert(returnObj!==null,"Could not create ink value from returned object of type "+typeof funcResult)}else{returnObj=new Void}this.state.PushEvaluationStack(returnObj)}BindExternalFunctionGeneral(funcName,func){this.IfAsyncWeCant("bind an external function");this.Assert(!this._externals.has(funcName),"Function '"+funcName+"' has already been bound.");this._externals.set(funcName,func)}TryCoerce(value){return value}BindExternalFunction(funcName,func){this.Assert(func!=null,"Can't bind a null function");this.BindExternalFunctionGeneral(funcName,args=>{this.Assert(args.length>=func.length,"External function expected "+func.length+" arguments");let coercedArgs=[];for(let i=0,l=args.length;i<l;i++){coercedArgs[i]=this.TryCoerce(args[i])}return func.apply(null,coercedArgs)})}UnbindExternalFunction(funcName){this.IfAsyncWeCant("unbind an external a function");this.Assert(this._externals.has(funcName),"Function '"+funcName+"' has not been bound.");this._externals.delete(funcName)}ValidateExternalBindings(){let c=null;let o=null;let missingExternals=arguments[1]||new Set;if(arguments[0]instanceof Container){c=arguments[0]}if(arguments[0]instanceof InkObject){o=arguments[0]}if(c===null&&o===null){this.ValidateExternalBindings(this._mainContentContainer,missingExternals);this._hasValidatedExternals=true;if(missingExternals.size==0){this._hasValidatedExternals=true}else{let message="Error: Missing function binding for external";message+=missingExternals.size>1?"s":"";message+=": '";message+=Array.from(missingExternals).join("', '");message+="' ";message+=this.allowExternalFunctionFallbacks?", and no fallback ink function found.":" (ink fallbacks disabled)";this.Error(message)}}else if(c!=null){for(let innerContent of c.content){let container=innerContent;if(container==null||!container.hasValidName)this.ValidateExternalBindings(innerContent,missingExternals)}for(let[key,value]of c.namedContent){this.ValidateExternalBindings(asOrNull(value,InkObject),missingExternals)}}else if(o!=null){let divert=asOrNull(o,Divert);if(divert&&divert.isExternal){let name=divert.targetPathString;if(name===null){return throwNullException("name")}if(!this._externals.has(name)){if(this.allowExternalFunctionFallbacks){let fallbackFound=this.mainContentContainer.namedContent.has(name);if(!fallbackFound){missingExternals.add(name)}}else{missingExternals.add(name)}}}}}ObserveVariable(variableName,observer){this.IfAsyncWeCant("observe a new variable");if(this._variableObservers===null)this._variableObservers=new Map;if(!this.state.variablesState.GlobalVariableExistsWithName(variableName))throw new StoryException("Cannot observe variable '"+variableName+"' because it wasn't declared in the ink story.");if(this._variableObservers.has(variableName)){this._variableObservers.get(variableName).push(observer)}else{this._variableObservers.set(variableName,[observer])}}ObserveVariables(variableNames,observers){for(let i=0,l=variableNames.length;i<l;i++){this.ObserveVariable(variableNames[i],observers[i])}}RemoveVariableObserver(observer,specificVariableName){this.IfAsyncWeCant("remove a variable observer");if(this._variableObservers===null)return;if(typeof specificVariableName!=="undefined"){if(this._variableObservers.has(specificVariableName)){let observers=this._variableObservers.get(specificVariableName);observers.splice(observers.indexOf(observer),1)}}else{let keys=this._variableObservers.keys();for(let varName of keys){let observers=this._variableObservers.get(varName);observers.splice(observers.indexOf(observer),1)}}}VariableStateDidChangeEvent(variableName,newValueObj){if(this._variableObservers===null)return;let observers=this._variableObservers.get(variableName);if(typeof observers!=="undefined"){if(!(newValueObj instanceof Value)){throw new Error("Tried to get the value of a variable that isn't a standard type")}let val=asOrThrows(newValueObj,Value);for(let observer of observers){observer(variableName,val.valueObject)}}}get globalTags(){return this.TagsAtStartOfFlowContainerWithPathString("")}TagsForContentAtPath(path){return this.TagsAtStartOfFlowContainerWithPathString(path)}TagsAtStartOfFlowContainerWithPathString(pathString){let path=new Path(pathString);let flowContainer=this.ContentAtPath(path).container;if(flowContainer===null){return throwNullException("flowContainer")}while(true){let firstContent=flowContainer.content[0];if(firstContent instanceof Container)flowContainer=firstContent;else break}let tags=null;for(let c of flowContainer.content){let tag=asOrNull(c,Tag);if(tag){if(tags==null)tags=[];tags.push(tag.text)}else break}return tags}BuildStringOfHierarchy(){let sb=new StringBuilder;this.mainContentContainer.BuildStringOfHierarchy(sb,0,this.state.currentPointer.Resolve());return sb.toString()}BuildStringOfContainer(container){let sb=new StringBuilder;container.BuildStringOfHierarchy(sb,0,this.state.currentPointer.Resolve());return sb.toString()}NextContent(){this.state.previousPointer=this.state.currentPointer.copy();if(!this.state.divertedPointer.isNull){this.state.currentPointer=this.state.divertedPointer.copy();this.state.divertedPointer=Pointer.Null;this.VisitChangedContainersDueToDivert();if(!this.state.currentPointer.isNull){return}}let successfulPointerIncrement=this.IncrementContentPointer();if(!successfulPointerIncrement){let didPop=false;if(this.state.callStack.CanPop(PushPopType.Function)){this.state.PopCallStack(PushPopType.Function);if(this.state.inExpressionEvaluation){this.state.PushEvaluationStack(new Void)}didPop=true}else if(this.state.callStack.canPopThread){this.state.callStack.PopThread();didPop=true}else{this.state.TryExitFunctionEvaluationFromGame()}if(didPop&&!this.state.currentPointer.isNull){this.NextContent()}}}IncrementContentPointer(){let successfulIncrement=true;let pointer=this.state.callStack.currentElement.currentPointer.copy();pointer.index++;if(pointer.container===null){return throwNullException("pointer.container")}while(pointer.index>=pointer.container.content.length){successfulIncrement=false;let nextAncestor=asOrNull(pointer.container.parent,Container);if(nextAncestor instanceof Container===false){break}let indexInAncestor=nextAncestor.content.indexOf(pointer.container);if(indexInAncestor==-1){break}pointer=new Pointer(nextAncestor,indexInAncestor);pointer.index++;successfulIncrement=true;if(pointer.container===null){return throwNullException("pointer.container")}}if(!successfulIncrement)pointer=Pointer.Null;this.state.callStack.currentElement.currentPointer=pointer.copy();return successfulIncrement}TryFollowDefaultInvisibleChoice(){let allChoices=this._state.currentChoices;let invisibleChoices=allChoices.filter(c=>{return c.isInvisibleDefault});if(invisibleChoices.length==0||allChoices.length>invisibleChoices.length)return false;let choice=invisibleChoices[0];if(choice.targetPath===null){return throwNullException("choice.targetPath")}this.ChoosePath(choice.targetPath,false);return true}VisitCountForContainer(container){if(container===null){return throwNullException("container")}if(!container.visitsShouldBeCounted){console.warn("Read count for target ("+container.name+" - on "+container.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c).");return 0}let count=0;let containerPathStr=container.path.toString();count=this.state.visitCounts.get(containerPathStr)||count;return count}IncrementVisitCountForContainer(container){let count=0;let containerPathStr=container.path.toString();if(this.state.visitCounts.has(containerPathStr))count=this.state.visitCounts.get(containerPathStr);count++;this.state.visitCounts.set(containerPathStr,count)}RecordTurnIndexVisitToContainer(container){let containerPathStr=container.path.toString();this.state.turnIndices.set(containerPathStr,this.state.currentTurnIndex)}TurnsSinceForContainer(container){if(!container.turnIndexShouldBeCounted){this.Error("TURNS_SINCE() for target ("+container.name+" - on "+container.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c).")}let containerPathStr=container.path.toString();let index=this.state.turnIndices.get(containerPathStr);if(typeof index!=="undefined"){return this.state.currentTurnIndex-index}else{return-1}}NextSequenceShuffleIndex(){let numElementsIntVal=asOrNull(this.state.PopEvaluationStack(),IntValue);if(!(numElementsIntVal instanceof IntValue)){this.Error("expected number of elements in sequence for shuffle index");return 0}let seqContainer=this.state.currentPointer.container;if(seqContainer===null){return throwNullException("seqContainer")}if(numElementsIntVal.value===null){return throwNullException("numElementsIntVal.value")}let numElements=numElementsIntVal.value;let seqCountVal=asOrThrows(this.state.PopEvaluationStack(),IntValue);let seqCount=seqCountVal.value;if(seqCount===null){return throwNullException("seqCount")}let loopIndex=seqCount/numElements;let iterationIndex=seqCount%numElements;let seqPathStr=seqContainer.path.toString();let sequenceHash=0;for(let i=0,l=seqPathStr.length;i<l;i++){sequenceHash+=seqPathStr.charCodeAt(i)||0}let randomSeed=sequenceHash+loopIndex+this.state.storySeed;let random=new PRNG(Math.floor(randomSeed));let unpickedIndices=[];for(let i=0;i<numElements;++i){unpickedIndices.push(i)}for(let i=0;i<=iterationIndex;++i){let chosen=random.next()%unpickedIndices.length;let chosenIndex=unpickedIndices[chosen];unpickedIndices.splice(chosen,1);if(i==iterationIndex){return chosenIndex}}throw new Error("Should never reach here")}Error(message,useEndLineNumber=false){let e=new StoryException(message);e.useEndLineNumber=useEndLineNumber;throw e}Warning(message){this.AddError(message,true)}AddError(message,isWarning=false,useEndLineNumber=false){let dm=this.currentDebugMetadata;let errorTypeStr=isWarning?"WARNING":"ERROR";if(dm!=null){let lineNum=useEndLineNumber?dm.endLineNumber:dm.startLineNumber;message="RUNTIME "+errorTypeStr+": '"+dm.fileName+"' line "+lineNum+": "+message}else if(!this.state.currentPointer.isNull){message="RUNTIME "+errorTypeStr+": ("+this.state.currentPointer+"): "+message}else{message="RUNTIME "+errorTypeStr+": "+message}this.state.AddError(message,isWarning);if(!isWarning)this.state.ForceEnd()}Assert(condition,message=null){if(condition==false){if(message==null){message="Story assert"}throw new Error(message+" "+this.currentDebugMetadata)}}get currentDebugMetadata(){let dm;let pointer=this.state.currentPointer;if(!pointer.isNull&&pointer.Resolve()!==null){dm=pointer.Resolve().debugMetadata;if(dm!==null){return dm}}for(let i=this.state.callStack.elements.length-1;i>=0;--i){pointer=this.state.callStack.elements[i].currentPointer;if(!pointer.isNull&&pointer.Resolve()!==null){dm=pointer.Resolve().debugMetadata;if(dm!==null){return dm}}}for(let i=this.state.outputStream.length-1;i>=0;--i){let outputObj=this.state.outputStream[i];dm=outputObj.debugMetadata;if(dm!==null){return dm}}return null}get mainContentContainer(){if(this._temporaryEvaluationContainer){return this._temporaryEvaluationContainer}else{return this._mainContentContainer}}}(function(Story){let OutputStateChange;(function(OutputStateChange){OutputStateChange[OutputStateChange["NoChange"]=0]="NoChange";OutputStateChange[OutputStateChange["ExtendedBeyondNewline"]=1]="ExtendedBeyondNewline";OutputStateChange[OutputStateChange["NewlineRemoved"]=2]="NewlineRemoved"})(OutputStateChange=Story.OutputStateChange||(Story.OutputStateChange={}))})(Story||(Story={}));exports.Story=Story;exports.InkList=InkList;Object.defineProperty(exports,"__esModule",{value:true})})},function(module,exports,__webpack_require__){const Story=__webpack_require__(0).Story;if(typeof AFRAME==="undefined"){throw new Error("Component attempted to register before AFRAME was available.")}const INK_LOADED_EVENT="ink-loaded";AFRAME.registerComponent("ink",{schema:{src:{type:"asset"},choice:{default:undefined}},multiple:false,init:function(){this.loader=new THREE.FileLoader},update:function(oldData){const data=this.data;const el=this.el;if(data.src&&data.src!==oldData.src){this.loader.load(data.src,json=>{const story=new Story(json);this.inkStory=story;this.continue();el.emit(INK_LOADED_EVENT,{story:story})})}if(this.data.choice&&data.choice.index>-1){this.continue(data.choice.index)}},remove:function(){},continue:function(choice=-1){if(choice>-1){this.inkStory.ChooseChoiceIndex(choice)}while(this.inkStory.canContinue){this.inkStory.Continue();const choices=this.inkStory.currentChoices.map(c=>{return{index:c.index,text:c.text}});this.el.emit("ink-continue",{text:this.inkStory.currentText,tags:this.inkStory.currentTags,choices:choices})}}});const STATE_UPDATE_EVENT="stateupdate";AFRAME.registerComponent("ink-state",{schema:{},multiple:false,init:function(){const el=this.el;const stateSystem=el.sceneEl.systems.state;if(!stateSystem){throw new Error("This component needs to have a registered state store with the aframe-state-component!")}el.addEventListener(INK_LOADED_EVENT,evt=>{const inkStory=evt.detail.story;var key;var inkKey;for(key in stateSystem.state){debugger;for(inkKey in inkStory.variablesState._globalVariables.keys()){if(inkKey===key){inkStory.ObserveVariable(inkKey,(varName,newValue)=>{el.sceneEl.emit("inkState",{[varName]:newValue})})}}}this.inkStory=inkStory});this.stateUpdated=this.stateUpdated.bind(this);el.sceneEl.addEventListener(STATE_UPDATE_EVENT,this.stateUpdated);el.addEventListener("ink-continue",evt=>{const detail=evt.detail;const tags=detail.tags;el.sceneEl.emit("currentStory",detail)})},update:function(oldData){},stateUpdated:function(evt){console.log("stateupdated");if(!this.inkStory)return;const state=evt.detail.state;var key;var inkKey;for(key in state){this.inkStory.variablesState._globalVariables.forEach(inkKey=>{if(inkKey===key){const inkVal=this.inkStory.variablesState[inkKey];if(!AFRAME.utils.deepEqual(inkVal,state[key])){this.inkStory.variablesState[inkKey]=state[key]}}})}},remove:function(){this.el.sceneEl.removeEventListener(STATE_UPDATE_EVENT,this.stateUpdated)}})}]);
